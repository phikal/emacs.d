#+TITLE:	A Semi-literate Emacs Configuration
#+OPTIONS:	email:nil H:5
#+KEYWORDS: emacs dotfile config

* Introductory comments
  This document is my configuration for [[https://gnu.org/s/emacs][GNU Emacs]], using [[https://org-mode.org/][Org Mode's]]
  [[https://en.wikipedia.org/wiki/Literate_programming][Literate Programming]] facilities to automatically extract and evaluate
  all the relevant code snippets, ignoring the documenting comments.

  To load this configuration, make sure you have the ~.org~ file locally
  on your system, and call it using ~org-babel-load-file~. Furthermore,
  make sure that you've loaded the ~cl-lib~ module with ~require~.

  This document, it's code and comments, are in the [[https://creativecommons.org/publicdomain/zero/1.0/deed][public domain]].

  The following configuration has been tested on a few different
  systems, with different Emacs versions, but nothing below 25. Ideally
  don't just copy the everything but read and adopt the code snippets
  you think will help /your/ configuration work better for /your/ use case.

  This configuration is more regularly updated [[https://zge.us.to/emacs.d.html][on my website]], and the
  [[https://zge.us.to/git/emacs.d/][Git history]] (+source) is also public (alternatively also to be found
  on [[https://github.com/phikal/emacs.d/][GitHub]]).

  Time of export: {{{time(%c)}}}.

** Personal Emacs History
   My first encounters with Emacs must have been somewhere around late
   2014, when I was looking around to find a proper text
   editor. Overwhelmed by the options, I tried a lot of things out, such
   as Sublime Text or Geany, but all of them felt missing, faulted
   incomplete or simply wrong. It didn't take long for me to understand
   that the two main players turned out to be some of the oldest ones:
   vi (ie. vim) and Emacs (ie. GNU Emacs).

   Knowing nothing, I trusted common opinion and went with Vi(m). And it
   was cool -- a +sin+ penance to say in an Emacs configuration. But while
   the foundations were good, it had problems with being extended,
   personalized, etc. Ultimately, I came to the conclusion that one
   shouldn't customize Vi(m), or at the very least keep it as minimal as
   possible (hence I use =nvi= and =vis= instead of Vim nowadays).

   Yet this conclusion wasn't achieved by itself. It took Emacs to prove
   this, by demonstrating a properly extendable "environment" to teach
   me...

   I remember that there was a bit of a gap between installing and using
   Emacs. For a while I even had issues remembering and recognizing the
   name! A particularly vivid memory is me looking through the Gnome (or
   Unity?) configuration program, and encountering the "input method"
   option, among which "Emacs" was an option -- I assumed it was related
   to Apple's computer brand... But when I opened Emacs for the first
   few times it seemed a bit overwhelming, (unnecessarily) complex and
   unhandy: everything was different. From names over the workflow
   (which I didn't even understand) to the keybindings. All I used to
   do, was open a file (=C-x C-f=), maybe move up and down (=M-v= and =C-v=)
   change the theme (using the menu bar) and then close Emacs (=C-x
   C-x=). That was pretty much all I knew.

   But somewhere around early 2015 (if not earlier) for some reason I
   can't quite remember I was drawn towards Emacs. Possibilities could
   be
   1. Me having have met "real" Emacs users, and drawing my attention to
	  the Editor, making me realize that it's not just a notepad with
	  inconvenient keybindings.
   2. Me having have engaged with Lisp, while to be fair not knowing all
	  it's potential understanding it's beauty.

   So I slowly started trying to configure Emacs. Retroactively it seems
   to me that the resources were far harder to find. Having no idea what
   to do (and lacking the patience to sit through the [[info:Emacs][Emacs Manual]]), I
   copied a few things from some blogs, a few things from some dotfile,
   some stuff from YouTube descriptions and others from Stackoverflow
   questions -- to put it simply, it was a mess, and stuff broke quite
   freqently. I kept on reading that Org mode was great, but I didn't
   ever get why (I did eventually). But for some reason I didn't stop
   using Emacs, but neither did I go too deep.

   After some 2 1/2 years of bare survival, ups and downs, I started to
   find out that people were writing literate configurations.

   Then I read [[https://sites.google.com/site/steveyegge2/tour-de-babel][an article]], that said the following:

   #+BEGIN_QUOTE
   They all used Emacs, of course. Hell, Eric Benson was one of the
   authors of XEmacs1. All of the greatest engineers in the world use
   Emacs. The world-changer types. Not the great gal in the cube next to
   you. Not Fred, the amazing guy down the hall. I'm talking about the
   greatest software developers of our profession, the ones who changed
   the face of the industry. The James Goslings, the Donald Knuths, the
   Paul Grahams, the Jamie Zawinskis, the Eric Bensons. Real engineers
   use Emacs. [...]

   Emacs is the 100-year editor.
   #+END_QUOTE

   Yes, it is a bit cringy -- but I liked the idea. So it didn't take
   long and I decided to rewrite my ~100-150 line configuration. My
   enthusiasm began to blossom somewhere around that time. And so, since
   February 2018 I have been maintaining this file.

** Why use org/babel?
   While it might appear to be a inconvenience at first, extracting ones
   configuration into a format like this one has multiple advantages, of
   which the main ones are:

   - My actual =init.el= is very short. All I do, disable filename
	 handlers, increase the garbage collection threshold, and (if
	 necessary) call Org/Babel. If the extracted file newer than the
	 this org file, I just load that file:

	 #+INCLUDE: "./init.el" src emacs-lisp :tangle no

   - Writing text with code (as opposed to code with comments) is much
	 more informative, and makes me justify whatever I add. This, one
	 the one hand contributes to simplicity, but also helps people who
	 are configuring their config get a better feeling for what to do
	 /and/ why.
   - After a while, every novice /should/ entirely rewrite their
	 configuration. In the beginning, one might just copy stuff from
	 Manuals, Wikis and Blogs -- and keep what sicks, but this results
	 in code that's hard to maintain and keep an overview. I pushed
	 myself to rewrite my configuration I started to write around
	 2014-15 and I enjoy a far better experience that had before. My
	 potential had increased and I have used the opportunity to learn
	 more about Emacs itself.

** Inspirations for writing this configuration
   Emacs is a tool you can use for years and always learn something new,
   which make you feel stupid for not having known. The fun part when
   writing a configuration like this one is that one actively learns
   these things, instead of accidentally pressing the wrong keybinding,
   and then going back to =C-h l= to find out what just happened.

   So for my own assistance, and maybe also for other lost souls,
   reading this in the lookout for tricks and wizardry (note: you
   probably won't find any of this in my config), I list here other very
   interesting configurations:

   - [[http://archive.is/qw0r8][Org Mode -- Organize Your Life in Plain Text!]] :: this is not
        strictly a config, but it's an overall great =org-mode=
        overview. Less on the topic of configurations, and more on the
        topic of =org-mode=, [[http://home.fnal.gov/~neilsen/notebook/orgExamples/org-examples.html][Eric H. Neilsen's example page]] is very
        useful to fall back on.
   - [[https://www.freebsd.org/doc/en/books/developers-handbook/emacs.html][Using Emacs as a Development Environment]] :: this offered a few
		c-mode related tricks
   - [[https://www.dgp.toronto.edu/~ghali/emacs.html][Sheruf Ghali's Emacs config]] :: recommendable due to being an
		expansive document with good (although not "literate")
		documentation and commentary.
   - [[https://caolan.org/dotfiles/emacs.html][Caolan McMahon's Emacs Configuration]] :: A lot of packages with
		helpful commentary. Very well structured.
   - [[https://github.com/jwiegley/dot-emacs][John Wiegley's (=use-package= creator) "dot-emacs"]] :: Always up to
		date and permanently changing, this configuration shows a lot of
		maturity.
   - [[https://tuhdo.github.io/emacs-tutor3.html][Tu Do's "Emacs Mini Manual (PART 3)"]] :: Part of a series that
		starts from nothing and gives a great introduction to Emacs. The
		last part (linked here) introduces and explains a lot of useful
		packages, as well as basic elisp concepts (=defun=, =add-to-list=,
		=mapc=, ...)
   - [[https://gitlab.com/j3kyl/dots/blob/master/gnu/.emacs.d/init.el][j3kyl's =init.el=]] :: Very extensive and occasionally obscure
		settings, structured and documented well enough to be
		understandable (sadly offline).
   - [[https://github.com/larstvei/dot-emacs/][Lard Tveito's "dot-emacs"]] :: Another literate configuration that
		demonstrates multiple packages with well written and helpful
		comments.
   - [[https://github.com/hrs/dotfiles/blob/master/emacs/.emacs.d/configuration.org][Harry R. Schwarz' (hrs) "dotfiles"]] :: Part of his overall
		configuration, hrs (Organizer of the NYC Emacs meetup) provides
		an extensive list of packages, tricks and tips.
   - [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's Emacs configuration]] :: /Very/ comprehensive but a bit
		disordered (IMO) literate configuration by the maintainer of the
		(very recommendable) [[http://sachachua.com/blog/category/emacs/][Emacs News]] newsletter.
   - [[https://github.com/codemac/config/blob/master/emacs.d/boot.org][Jeff Mickey's (codemac) Emacs]] :: A bit untidy but extensive/long
		and quite clever literate configuration. Many variables worth
		knowing about, as well as good, thoughtful commentary.
   - [[https://mrblog.nl/emacs/config.html][Marcel van der Boom's "Orgmode configuration"]] :: Impressively long
        configuration with more-than-average commentary and many custom
        functions to extend the default behavior of the many packages
        mentioned. Seems to be written with a German keyboard in mind.
   - [[http://home.thep.lu.se/~karlf/emacs.html][Karl Fogelmark's .emacs]] :: A lot of functions and keybinding-tables
        and otherwise helpful comments, yet written with pre-Emacs 24.1
        in mind so the configuration is a bit verbose.
   - [[https://git.sr.ht/~jakob/.emacs.d][Jakob L. Kreuze's .emacs.d]] :: Despite being described as "little
        rough around the edges", I found this a very interesting
        configurations to read (as of writing, <2018-12-30 Sun>). There
        are quite a few unusual options that are played around with,
        that I've adopted in the following document too.
   - [[https://github.com/wasamasa/dotemacs/blob/master/init.org][Vasilij Schneidermann's dotemacs]] :: More of a classical literate
        configuration, both in standing as well as style. Well worth
        reading for various hacks or just for learning.
   - [[http://chneukirchen.org/dotfiles/.emacs][Leah Neukirchen's .emacs]] :: A fairly old configuration (from 2001)
        that has been maintained up until fairly recently (2018, as of
        writing). Interesting for unusual functions and
        macros. Especially interesting: the =bang= Function.
   - [[https://github.com/danielmai/.emacs.d/blob/master/config.org][Daniel Mai's .emacs.d]] :: Certainly one of the better literate Emacs
		configurations I have found in a while, leveraging =use-package=
        but also showing and explaining quite interesting variables I
        have also chosen to adopt myself.

   All of these configurations are worth reading and re-reading from
   time to time, since one can always find out something new to adopt
   into his/her own configuration.

   A more comprehensive list can be found [[https://github.com/caisah/emacs.dz][here]].

** Short note on my directory structure
   While this configuration aims for a certain degree of portability,
   this isn't universally the case, since it's my personal setup, not a
   cool prelude. Portability is maintained between the devices I use
   Emacs on, by assuming a certain standardized directory structure, as
   follows:

   | Directory                   | Use                                                   |
   |-----------------------------+-------------------------------------------------------|
   | =~/=                          | home                                                  |
   | =~/code/=                     | programming and sysadmin related files                |
   | =~/code/{c,haskell,go,...}=   | directories devoted to specific programming languages |
   | =~/code/etc/...=              | various other projects (including emacs source)       |
   | =~/dl/=                       | downloads gathering directory, preferably empty       |
   | =~/doc/=                      | texts, presentations and notes                        |
   | =~/doc/org/=                  | most org-mode related files                           |
   | =~/media/=                    | general directory for digial media                    |
   | =~/media/{img,vid,music,...}= | specific media directories                            |
   | =~/etc/=                      | various other directories                             |
   | =~/etc/bin/=                  | user binaries                                         |
   | =~/etc/{mail,news,pub}=       | gnus related directories                              |

   When porting or copying from this configuration, these notes might
   help.

** Software I have installed to aid Emacs
   Emacs makes great use of external software, that's also installed on
   the same system. The following list helps me remember what I have to
   install on a new system, and for what purpose:

   - msmtp, mpop, notmuch :: [[*Mail][Mail]]
   - gpg :: authinfo.gpg de-/encyrption
   - curl :: [[*Feed Syndication][Feed Syndication]]
   - ledger :: [[*Accounting][Double-entry Accounting]]
   - git :: [[*Version%20Control][Version Control]] (eg. for this file)
   - aspell :: [[Spell%20Checking][Spell Checking]]
   - rg :: [[*Project Managment][Project Managment]] and [[*Goto Source][Source Discovery]]
   - cmark :: [[*Markdown][Markdown]]

   Compilers and interpreters for specific programming enjoyments aren't
   listed here, since I don't necessarily have all of them installed,
   even if they are set up to work in Emacs.

* General Setup
** Lexical Scoping
   #+BEGIN_SRC emacs-lisp
	 ;;; -*- lexical-binding: t; eval: (view-mode 1) -*-
   #+END_SRC

   All code written in this file, shall be [[https://stackoverflow.com/questions/1047454/what-is-lexical-scope]["Lexically Scoped"]].

** Package Management
   #+BEGIN_SRC emacs-lisp
	 (require 'package)
	 (setq package-enable-at-startup nil)
	 (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/"))
	 (package-initialize)
   #+END_SRC

   Only use ~melpa-stabe~ besides the standard gnu repository (which
   should be in ~package-archives~ by default). This makes sure that all
   the packages I install (see /[[Packages%20and%20Other%20Configurations][Packages]]/) have a higher chance on
   /not-breaking/ due to random updates..

** User information
   #+BEGIN_SRC emacs-lisp
	 (setq user-full-name "Philip K."
		   user-mail-address
		   (format "%s%c%s" "philip" (- ?A 1) "warpmail.net"))
   #+END_SRC

   Personal data?

** Appearance
*** Initially deactivated Modes
	#+BEGIN_SRC emacs-lisp
	  (scroll-bar-mode -1)
	  (menu-bar-mode -1)
	  (tool-bar-mode -1)
	  (blink-cursor-mode -1)
	  (tooltip-mode -1)
	#+END_SRC

	Since I usually don't need my mouse to use Emacs, I turn off all GUI
	related tools, like scroll-, toolbars, etc. This is done early on to
	avoid redrawing during startup.

	As an additional hack, I sometimes place the following in my
	=.Xresources= file, which further improves the startup speed slightly:

	#+BEGIN_EXAMPLE
	emacs.toolBar: 0
	emacs.menuBar: 0
	emacs.verticalScrollBars: off
	emacs.fullscreen: fullboth
	#+END_EXAMPLE

*** Fonts
	#+BEGIN_SRC emacs-lisp
	  (set-face-font 'default "IBM Plex Mono 11")
	  (set-face-font 'variable-pitch "IBM Plex Sans 11")
	  (set-face-font 'fixed-pitch "Monospace 11")
	#+END_SRC

	My fonts are configured and changed frequently, making any more
	significant commentary on this code redundant.

*** Parentheses
	#+BEGIN_SRC emacs-lisp
	  (setq show-paren-delay 0
			show-paren-when-point-inside-paren t)
	  (show-paren-mode t)
	#+END_SRC

	To extend the default Emacs appearance, matching parentheses are
	highlighted, which is helpful when working with Lisp code.

*** Startup actions
	#+BEGIN_SRC emacs-lisp
	  (setq inhibit-startup-screen t
			inhibit-startup-buffer-menu t
			inhibit-startup-message t
			inhibit-startup-hooks t)
	#+END_SRC

	In accordance to a minimalist and fast startup, I tell Emacs to not
	open the standard startup buffer (with a timestamp of when I opened
	Emacs), since I never use it anyways.

*** Whitespace and Formatting
	#+BEGIN_SRC emacs-lisp
	  (setq-default fill-column 72
					tab-width 4)
	#+END_SRC

	These settings are purely personal preferences.

*** Buffer Boundaries
	#+BEGIN_SRC emacs-lisp
	  (setq-default indicate-buffer-boundaries
					'((top . right)
					  (bottom . right)
					  (t . nil)))
	#+END_SRC

	Sometimes it's not obvious if you're at the top or bottom of a
	buffer. So I enable indicators that can tell me precisely that.

*** Empty Lines
	#+BEGIN_SRC emacs-lisp
	  (defun turn-indicate-empty-lines-on ()
		(setq indicate-empty-lines t))

	  (add-hook 'prog-mode-hook #'turn-indicate-empty-lines-on)
	  (add-hook 'text-mode-hook #'turn-indicate-empty-lines-on)
	  (add-hook 'dired-mode-hook #'turn-indicate-empty-lines-on)
	  (add-hook 'comint-mode-hook #'turn-indicate-empty-lines-on)
	#+END_SRC

	This option makes Emacs populate the left-hand fringe with little
	lines indicating space the frame uses, but the buffer doesn't. This
	only makes sense for buffers I edit manually, like text or programs
	(less so in Eshell and Magit) so I enable it using a hook.

*** Exiting Emacs
	#+BEGIN_SRC emacs-lisp
	  (setq confirm-kill-emacs #'yes-or-no-p)
	#+END_SRC

	While it's not quite "appearance"-related, this will prevent Emacs
	from being accidentally closed when I type =C-x C-c= instead of =C-c
	C-x=.

*** Extra-Emacs Clipboard
	#+BEGIN_SRC emacs-lisp
	  (setq select-enable-clipboard t)
	#+END_SRC

	Having the ability to interact with the system clipboard is very
	welcome, especially when copying code from a (now =eww=) web browser.

	#+BEGIN_SRC emacs-lisp
	  (setq save-interprogram-paste-before-kill t)
	#+END_SRC

	Also don't forget what it is the clipboard before text is killed, by
	adding it to the kill-ring.

	#+BEGIN_SRC emacs-lisp
	  (setq mouse-yank-at-point t)
	#+END_SRC

	Additionally, don't follow the mouse, but insert at the current point.

*** Frame resizing
	#+BEGIN_SRC emacs-lisp
	  (setq frame-resize-pixelwise t)
	#+END_SRC

	When using graphical Emacs, this option enables more flexible
	resizing of the entire frame.

*** Window resizing
	#+BEGIN_SRC emacs-lisp
	  (setq window-combination-resize t)
	#+END_SRC

	This option make Emacs split windows in a more sane and visually
	pleasing manner, ie. proportionally.
*** Disable graphical dialogues
	#+BEGIN_SRC emacs-lisp
	  (setq use-dialog-box nil)
	#+END_SRC

	Just don't create graphical pop-ups (especially when Emacs starts
	up).

*** Minibuffer height
	#+BEGIN_SRC emacs-lisp
	  (setq max-mini-window-height 0.40)
	#+END_SRC

	I like executing commands with =M-!=, but I don't like new buffers and
	windows being created. To remedy this, I lessen Emacs general
	sensitivity as to what is "too much" for the Minibuffer from 25% (as
	of writing) to 40% of the window height.

** Emacs-System Configuration
*** Cross-session Configuration
	#+BEGIN_SRC emacs-lisp
	  (setq history-delete-duplicates t
			savehist-save-minibuffer-history t
			savehist-additional-variables '(kill-ring
											search-ring
											eshell-history-ring
											compile-command
											recentf-list
											calc-stack)
			savehist-ignored-variables '(tmm--history
										 yes-or-no-p-history))

	  (savehist-mode t)
	#+END_SRC

	The preceding two function calls make sure that in-between opening
	and closing Emacs (for example when I have to shut down my computer)
	buffers and windows are saved, as well as minibuffer inputs plus the
	contents of ~kill-ring~, ~search-ring~ and ~compile-command~. Other
	variables, which are not needed are disregarded.

	#+BEGIN_SRC emacs-lisp
	  (desktop-save-mode t)
	  (setq desktop-restore-eager 8
			desktop-files-not-to-save
			(rx (or (seq bol "/" (zero-or-more (not (any "/" ":"))) ":")
					(seq "(ftp)" eol)
					(seq "*" (one-or-more not-newline) "*"))))
	#+END_SRC

	To not loose all the buffers between sessions, =desktop-save-mode=
	keeps track of buffers before Emacs exists, /but/ doesn't keep track of
	the frame layout. Furthermore, no buffers are "lazily" restored, but
	instead all at once, since otherwise this leads to an annoying
	behavior where buffers are being restored and Emacs, but because I
	stopped typing for a second.

	#+BEGIN_SRC emacs-lisp
	  (save-place-mode t)
	#+END_SRC

	When re-entering a file, return to that place where I was when I
	left it the last time.
*** Load Path
	#+BEGIN_SRC emacs-lisp
	  (add-to-list 'load-path
				   (expand-file-name "lisp/" user-emacs-directory))
	#+END_SRC

	I have some custom external scripts lying in the =lisp= sub directory,
	and for Emacs to know about them, I add it to the =load-path=.
*** Encoding
	#+BEGIN_SRC emacs-lisp
	  (setq locale-coding-system 'utf-8)
	  (set-terminal-coding-system 'utf-8)
	  (set-keyboard-coding-system 'utf-8)
	  (set-selection-coding-system 'utf-8)
	  (prefer-coding-system 'utf-8)
	#+END_SRC

	Assume UTF8 by default.

*** Pager
	#+BEGIN_SRC emacs-lisp
	  (setenv "PAGER" "cat")
	#+END_SRC

	Prevent interactive processes from using a "regular" pager such as
	less, view or more, and instead just let Emacs do the job.

*** Emacs C source
	#+BEGIN_SRC emacs-lisp
	  (let ((c-source (expand-file-name "~/code/etc/emacs/src")))
		(when (file-directory-p c-source)
		  (setq find-function-C-source-directory c-source)))
	#+END_SRC

	In case I have the Emacs C-source locally installed, I inform my
	current session about it, in case I want to inspect some low level
	code.

*** RFC
	#+BEGIN_SRC emacs-lisp
	  (setq ffap-rfc-directories '("/usr/share/doc/RFC/links/"))
	#+END_SRC

	Since I've installed [[https://packages.debian.org/sid/doc-rfc][doc-rfc]] on my system, I have all RFCs installed
	locally. Therefore, ffap doesn't have to use a broken FTP mirror to
	parse =RFC2551=, but can open it directly.

*** Time Locale
	#+BEGIN_SRC emacs-lisp
	  (setq system-time-locale "C")
	#+END_SRC

	Force Emacs (especially =org-mode=) to use English timestamps.

*** Shell comands
	#+BEGIN_SRC emacs-lisp
	  (setq-default async-shell-command-display-buffer nil
					async-shell-command-buffer 'new-buffer)
	#+END_SRC

	When asynchronously running commands, only create a /new/ output
	buffer, if one is needed.

*** Auto-reverting
	#+BEGIN_SRC emacs-lisp
	  (setq global-auto-revert-non-file-buffers t)
	  (setq auto-revert-verbose nil)
	#+END_SRC

	Don't print messages to the minibuffer about reverting files
	(ie. updating changes on the disk in buffers).

** Emacs-Internal Configuration
*** Backups
	#+BEGIN_SRC emacs-lisp
	  (setq-default backup-directory-alist
					`(("" . ,(expand-file-name "backup/" user-emacs-directory)))
					auto-save-default nil
					backup-by-copying t
					delete-old-versions t)
	#+END_SRC

	The default Emacs backup system is pretty annoying, so these are a
	some helpful tips I've gathered from around the internet, with a few
	modifications based on experience (eg. having have been saved by the
	backup system, more than just a few times).

	*Note:* This is also probably one of the oldest parts on my
	configuration, staying mostly unchanged since mid-late 2014, when
	copied the code from [[https://stackoverflow.com/a/151946][this StackOverflow answer]].

*** Disable lockfiles
	#+BEGIN_SRC emacs-lisp
	  (setq create-lockfiles nil)
	#+END_SRC

	Lockfiles appear when a file is opened and confuses some tools. I
	trust /myself/ to not come into a situation where lockfiles are
	needed, and have therefore disabled them.

*** "Large Files"
	#+BEGIN_SRC emacs-lisp
	  (setq large-file-warning-threshold 40000000)
	#+END_SRC

	Don't warn me about /larger-but-not-actually-that-large/ files.

*** Scrolling
	#+BEGIN_SRC emacs-lisp
	  (setq scroll-preserve-screen-position t
			scroll-conservatively 10000
			scroll-step 1)
	#+END_SRC

	Prevent unnecessary moving of the buffer, when windows or frames
	change.

*** Prefer newer Bytecode
	#+BEGIN_SRC emacs-lisp
	  (setq load-prefer-newer t)
	#+END_SRC

	Quite simple trick to avoid a few bugs that might arise from older
	bytecode being used, even though the elisp file has changed.

*** Disabled functions
	#+BEGIN_SRC emacs-lisp
	  (setq disabled-command-function nil)
	#+END_SRC

	By default Emacs disables some commands that have to be manually
	enabled by the user, when the keybinding is used or the function is
	called. This snippet ([[https://www.emacswiki.org/emacs/DisabledCommands][source]]) disables this by default, thus
	enabling all commands.

*** Help-buffers
	#+BEGIN_SRC emacs-lisp
	  (setq help-window-select nil)
	#+END_SRC

	Usually when using Emacs' online-help system, it doesn't move the
	active point to the new buffer, making me type =C-x o= every time
	(nearly as an instinct). Telling Emacs to do otherwise, should make
	life a bit easier.

*** Aliases
	#+BEGIN_SRC emacs-lisp
	  (defalias 'yes-or-no-p 'y-or-n-p)
	  (defalias 'perl-mode 'cperl-mode)
	  (defalias 'ff 'find-file)
	  (defalias 'ffo 'find-file-other-window)
	#+END_SRC

	Don't use =perl-mode=, but =cperl-mode=! And instead of having to type
	"yes" or "no" when emacs asks a question, respectively accept "y" or
	"n" instead.

*** Abbrevations
	#+BEGIN_SRC emacs-lisp
	  (setq abbrev-file-name (expand-file-name "abbrev.defs" user-emacs-directory)
			save-abbrevs 'silent)
	#+END_SRC

	This setup will automatically initialize and save new abbreviations,
	which are used for [[Writing][writing]].

*** Emacs-generated files
	#+BEGIN_SRC emacs-lisp
	  (let ((custom-el (expand-file-name "custom.el" user-emacs-directory)))
		(setq custom-file custom-el)
		(when (file-exists-p custom-el)
		  (load custom-file)))
	#+END_SRC

	I previously attempted to set =custom-file= to =/dev/null/=, but sadly I
	kept getting the message that the find could not be
	found. Therefore, to not clutter =init.el=, I dump all the
	configurations in =~/.emacs.d/custom.el=.

*** Sentences
	#+BEGIN_SRC emacs-lisp
	  (setq sentence-end-double-space nil)
	#+END_SRC

	I dislike the standard sentence definition Emacs uses, since for me
	a sentence is just a publication mark, followed by white space.
	Optionally, non-word characters are acceptable between the
	punctuation and the whitespace, like when writing =_No!_= in Markdown.

*** Window Focus
	#+BEGIN_SRC emacs-lisp
	  (add-hook 'occur-mode-hook (lambda () (pop-to-buffer "*Occur*" nil t)))
	  (add-hook 'help-mode-hook (lambda () (pop-to-buffer "*Help*" nil t)))
	#+END_SRC

	These hooks raise windows when they are created. I'm trying to find
	a cleverer way using =display-buffer-alist=, but haven't managed to do
	so yet.

*** Searching
	#+BEGIN_SRC emacs-lisp
	  (setq lazy-highlight-initial-delay 0)
	#+END_SRC

	When using isearch, Emacs highlights possible matches. By default
	this is delayed just enough to be annoying. I say: "don't wait,
	highlight!".

	#+BEGIN_SRC emacs-lisp
	  (define-key isearch-mode-map (kbd "C-o")
		(lambda () (interactive)
		  (occur (if isearch-regexp isearch-string (regexp-quote isearch-string)))
		  (isearch-exit)))
	#+END_SRC

	This hack let's me easily enter occur when searching the buffer.
	From there, one can type =e= to edit like with wdired.

*** Mark Ring
	#+BEGIN_SRC emacs-lisp
	  (setq set-mark-command-repeat-pop t
			mark-ring-max 32)
	#+END_SRC

	From the manual:

	#+BEGIN_QUOTE
	If you set set-mark-command-repeat-pop to non-nil, then immediately
	after you type C-u C-<SPC>, you can type C-<SPC> instead of C-u
	C-<SPC> to cycle through the mark ring.
	#+END_QUOTE

	and

	#+BEGIN_QUOTE
	The variable mark-ring-max specifies the maximum number of entries
	to keep in the mark ring. This defaults to 16 entries. If that many
	entries exist and another one is pushed, the earliest one in the
	list is discarded.
	#+END_QUOTE

*** Recent files
	#+BEGIN_SRC emacs-lisp
	  (recentf-mode t)
	#+END_SRC

	For tools like [[*Project%20Managment][projectile]], recentf is enabled, so to easily access
	recently opened files.

*** Setting the right mode
	#+BEGIN_SRC emacs-lisp
	  (setq-default major-mode (lambda ()
								 (unless buffer-file-name
								   (let ((buffer-file-name (buffer-name)))
									 (set-auto-mode)))))
	#+END_SRC

	When creating new buffers, use =auto-mode-alist= to automatically set
	the major mode. Snippet from [[https://emacs.stackexchange.com/a/2555][Stackoverflow]].

*** Writing while region is active
	#+BEGIN_SRC emacs-lisp
	  (delete-selection-mode t)
	#+END_SRC

	When I've selected a region, and I type something, the region is
	supposed to be deleted automatically.

** Emacs-Subsystem Configuration
*** Eldoc
	#+BEGIN_SRC emacs-lisp
	  (setq eldoc-idle-delay 0.1)
	#+END_SRC

	Eldoc is quite nice when programming, it shows me information about
	the symbol the point is currently on. All I want it for it to not
	wait for that long before it does that.

*** Uniquify
	#+BEGIN_SRC emacs-lisp
	  (setq uniquify-buffer-name-style 'forward
			uniquify-after-kill-buffer-p t
			uniquify-ignore-buffers-re "^\\*")
	#+END_SRC

	It happens far too often that I open two files with the same name,
	eg. two =Makefile= or =.gitignore= files. To make this "mistake" more
	pleasant, I customize the default behavior.

*** Calendar
	#+BEGIN_SRC emacs-lisp
	  (with-eval-after-load 'calendar
		(setq calendar-week-start-day 1
			  calendar-longitude 10.9887
			  calendar-latitude 49.4771
			  calendar-date-style 'iso
			  calendar-christian-all-holidays-flag t
			  calendar-mark-holidays-flag t
			  calendar-mark-diary-entries-flag t)
	#+END_SRC

	The default Emacs calendar configuration is a bit simplistic and
	peculiar. I've always been used to weeks starting on Monday and
	prefer ISO over the American date format, so I set calendar to work
	accordingly. Furthermore, I request holidays and diary entries to be
	highlighted.

	#+BEGIN_SRC emacs-lisp
	  (add-hook 'calendar-move-hook
				(lambda ()
				  (when (calendar-check-holidays (calendar-cursor-to-date t nil))
					(calendar-cursor-holidays))))
	#+END_SRC

	This hook prints the holiday under the cursor to the minibuffer, in
	there there is any, since this seemingly cannot be enabled by
	default.

	#+BEGIN_SRC emacs-lisp
	  (setq holiday-general-holidays
			'((holiday-fixed 1 1 "New Year")
			  (holiday-fixed 5 1 "1st Mai")
			  (holiday-fixed 10 3 "Tag der Deutschen Einheit")
			  (holiday-fixed 12 31 "Sylvester")))

	  (setq holiday-christian-holidays
			'((holiday-fixed 1 6 "Heilige Drei Könige")
			  (holiday-easter-etc -48 "Rosenmontag")
			  (holiday-easter-etc  -2 "Karfreitag")
			  (holiday-easter-etc   0 "Ostersonntag")
			  (holiday-easter-etc  +1 "Ostermontag")
			  (holiday-easter-etc +39 "Christi Himmelfahrt")
			  (holiday-easter-etc +49 "Pfingstsonntag")
			  (holiday-easter-etc +50 "Pfingstmontag")
			  (holiday-easter-etc +60 "Fronleichnam")
			  (holiday-fixed 8 15 "Mariae Himmelfahrt")
			  (holiday-fixed 11 1 "Allerheiligen")
			  (holiday-float 11 0 1 "Totensonntag" 20)
			  (holiday-float 12 0 -4 "1. Advent" 24)
			  (holiday-float 12 0 -3 "2. Advent" 24)
			  (holiday-float 12 0 -2 "3. Advent" 24)
			  (holiday-float 12 0 -1 "4. Advent" 24)
			  (holiday-fixed 12 25 "1. Weihnachtstag")
			  (holiday-fixed 12 26 "2. Weihnachtstag")))
	#+END_SRC

	Based on the [[https://www.emacswiki.org/emacs/CalendarLocalization#toc32][EmacsWiki /Calendar Localization/ Article]], I list inform
	Emacs German/Bavarian holidays, since these are relevant to me.

	#+BEGIN_SRC emacs-lisp
	  (add-hook 'calendar-mode-hook #'toggle-truncate-lines)
	#+END_SRC

	Since my screen is just too short to display the calendar when the
	frame is split, I automatically truncate the lines, to make sure
	that it readable at all.

	#+BEGIN_SRC emacs-lisp
		(define-key calendar-mode-map (kbd "f") #'calendar-forward-day)
		(define-key calendar-mode-map (kbd "F") #'calendar-forward-week)
		(define-key calendar-mode-map (kbd "b") #'calendar-backward-day)
		(define-key calendar-mode-map (kbd "B") #'calendar-backward-week))
	#+END_SRC

** Registers
   #+BEGIN_SRC emacs-lisp
	 (defvar zge/registers
	   `((?~ "~")
		 (?S "~/.stumpwmrc")
		 (?d "~/dl/")
		 (?b "~/etc/bin/")
		 (?\; "~/code")
		 (?w "~/code/web/www/")
		 (?W "~/code/web/")
		 (?s "~/code/web/start.md")
		 (?c ,(expand-file-name "conf.org" user-emacs-directory))
		 (?C ,(expand-file-name "custom.el" user-emacs-directory))
		 (?D ,(expand-file-name "diary" user-emacs-directory))
		 (?o "~/doc/org/")
		 (?n "~/doc/org/notes.org")
		 (?p "~/doc/org/pers.org")
		 (?j "~/doc/org/ws18.org")
		 (?r "~/doc/read/")
		 (?u "~/doc/uni/")
		 (?l ,(format-time-string "~/doc/ledger/%Y/%m.lg"))
		 (?m "~/media/")
		 (?U "/ssh:uni:")
		 (?I "/ssh:ibis:"))
	   "Personal registers")

	 (setq register-alist (mapcar (pcase-lambda (`(,key  ,file))
									(cons key (cons 'file file)))
								  zge/registers))
   #+END_SRC

   To quickly access certain files I tend to frequently use, I use
   Emacs's [[info:emacs#File%20Registers][file registers]].

** Helper Functions and Macros
*** Working with PATH
	#+BEGIN_SRC emacs-lisp
	  (defun add-to-PATH (dir)
		"Add `dir' to environmental variable PATH as well as
	  `exec-path'."
		(let ((path (split-string (getenv "PATH") ":")))
		  (unless (member dir path)
			(push dir path))
		  (add-to-list 'exec-path dir)
		  (setf (getenv "PATH") (string-join path ":"))))
	#+END_SRC

	Adding a directory to the =PATH= environmental variable can be
	cumbersome at times, since it requires using =getenv= multiple times
	and it isn't pretty to check if a directory is always included every
	time. This is what =add-to-PATH= seeks to fix.

	#+BEGIN_SRC emacs-lisp
	  (defun remove-from-PATH (dir)
		"Remove dir from environmental variable PATH and `exec-path'."
		(let* ((path (split-string (getenv "PATH") ":"))
			   (path-new (remove dir path)))
		  (delete dir exec-path)
		  (setf (getenv "PATH") (string-join path-new ":"))))
	#+END_SRC

	And as a complement to =add-to-PATH=, =remove-from-PATH= does what one
	would expect it to do.

	#+BEGIN_SRC emacs-lisp
	  (add-to-PATH (expand-file-name "~/etc/bin"))
	#+END_SRC

	And I use the opportunity to add my local binary directory to Emacs'
	know paths.

*** Set value locally
	#+BEGIN_SRC emacs-lisp
	  (defmacro setl (sym val)
		"Produce a lambda expression that locally sets a value"
		`(function (lambda () (setq-local ,sym ,val))))
	#+END_SRC

	Some modes will have to have buffer-local variables, loaded by
	hooks. To make it a bit easier to work with these, this macro
	produces a lambda expression that just set local values to a constant.

* Packages and Other Configurations
  #+BEGIN_SRC emacs-lisp
	(unless (package-installed-p 'use-package)
	  (package-refresh-contents)
	  (package-install 'use-package t))
	(setq-default use-package-always-defer t
				  use-package-always-ensure t)
  #+END_SRC

  Generally, always defer packages and ensure their installation, unless
  otherwise specified. It is assumed that =use-package= has already been
  installed.

** Utilities
*** Text Manipulation
**** Dynamic Expansion
	 #+BEGIN_SRC emacs-lisp
	   (setq hippie-expand-try-functions-list
			 '(try-expand-dabbrev-visible
			   try-expand-dabbrev
			   try-expand-dabbrev-from-kill
			   try-expand-dabbrev-all-buffers
			   try-complete-file-name-partially
			   try-complete-file-name
			   try-expand-all-abbrevs))
	 #+END_SRC

	 For some reason =hippie-expand= (and it's little sister =dabbrev=) was
	 one of the tools I never noticed but couldn't forget about when I
	 did. Expanding dynamically and even quite intelligently, in all
	 buffers is something one might not quite understand at first, or
	 even find confusing, but especially in the context of Emacs is
	 really cool. To aid this experience, I've set and ordered a few
	 extra expand functions, I find helpful.

**** Expand Region
	 #+BEGIN_SRC emacs-lisp
	   (use-package expand-region
		 :bind ("C-=" . er/expand-region))
	 #+END_SRC

	 The =expand-region= utility is a helpful function that let's the user
	 select increasingly larger semantically meaningful regions. I've
	 bound it to the recommended default

**** Jump in Buffer
	 #+BEGIN_SRC emacs-lisp
	   (use-package avy
		 :config
		 (avy-setup-default)
		 (setq avy-background t)
		 :bind (("C-z" . avy-goto-word-1)
				("C-M-z" . avy-goto-char)))
	 #+END_SRC

	 When editing text, most time isn't (or shouldn't be) spent on
	 manipulating text /per se/.

*** Extensions
**** Auto-completion
	 #+BEGIN_SRC emacs-lisp
	   (use-package ivy
		 :demand
		 :diminish
		 :commands ivy-mode
		 :config
		 (setq ivy-wrap t
			   ivy-height 6
			   ivy-display-style 'fancy
			   ivy-use-virtual-buffers t
			   ivy-case-fold-search-default t
			   ivy-re-builders-alist '((t . ivy--regex))
			   enable-recursive-minibuffers t)
		 (ivy-mode t)
		 :bind (:map ivy-minibuffer-map
					 ("<RET>" . ivy-alt-done)))
	 #+END_SRC

	 I use Ivy to extend the default =find-file=, =switch-to-buffer=,
	 etc. commands. Compared to it's alternatives, Ivy is simpler that
	 Helm but more powerful (and faster) than Ido.

	 #+BEGIN_SRC emacs-lisp
	   (use-package counsel
		 :after ivy
		 :diminish
		 :commands counsel-mode
		 :config
		 (setq counsel-find-file-at-point t)
		 (counsel-mode t)
		 (dolist (cmd '(yank-pop describe-bindings))
		   (define-key counsel-mode-map `[remap ,cmd] nil))
		 :bind (("C-c s" . counsel-rg)
				("C-c f" . counsel-locate)
				("C-x C-/" . counsel-org-goto-all)))
	 #+END_SRC

	 Counsel extends this to further integrate Ivy features into default
	 commands, such as =M-x=, =C-x b= or =C-x C-f=.

	 #+BEGIN_SRC emacs-lisp
	   (use-package flx
		 :after ivy
		 :config
		 (add-to-list 'ivy-re-builders-alist '(counsel-M-x . ivy--regex-fuzzy)))
	 #+END_SRC

	 Additionally, use flexible matching for =M-x=.

**** Buffer overview
	 #+BEGIN_SRC emacs-lisp
	   (use-package ibuffer
		 :config
		 (require 'ibuf-ext)
		 (define-ibuffer-column size-human (:name "Size" :inline t)
		   (cond ((> (buffer-size) (lsh 1 20))
				  (format "%7.1fM" (/ (buffer-size) (lsh 1 20))))
				 ((> (buffer-size) (lsh 1 12))
				  (format "%7.0fk" (/ (buffer-size) (lsh 1 10))))
				 ((> (buffer-size) (lsh 1 10))
				  (format "%7.1fk" (/ (buffer-size) (lsh 1 10))))
				 (t (format "%8d" (buffer-size)))))
		 (setq ibuffer-expert t
			   ibuffer-formats
			   '((mark modified read-only locked " "
					   (name 18 18 :left :elide) " "
					   (size-human 9 -1 :right) " "
					   (mode 16 16 :left :elide) " "
					   filename-and-process)
				 (mark " " (name 16 -1) " " filename))
			   ibuffer-show-empty-filter-groups nil
			   ibuffer-hidden-filter-groups '("Dired" "IRC" "Gnus")
			   ibuffer-saved-filter-groups
			   `(("default"
				  ("Dired" (mode . dired-mode))
				  ("Org" (mode . org-mode))
				  ("IRC" (mode . rcirc-mode))
				  ("Ledger" (mode . ledger-mode))
				  ("PDF" (mode . pdf-view-mode))
				  ("Man Pages" (mode . Man-mode))
				  ("Emacs" (or (name . ,(rx bos "*scratch*" eos))
							   (name . ,(rx bos "*Messages*" eos))
							   (name . ,(rx bos "*Backtrace*" eos))
							   (name . ,(rx bos "*info*" (? "<" (+ digit) ">") eos))
							   (name . ,(rx bos "*Help*" eos))
							   (name . ,(rx bos "*Apropos*" eos))))
				  ("Emacs Source"
				   (or (directory . ,(rx bos "~/code/etc/emacs/src/"))
					   (directory . ,(rx bos "/usr/share/emacs/26.1/"))))
				  ("Gnus" (or (mode . message-mode)
							  (mode . bbdb-mode)
							  (mode . mail-mode)
							  (mode . gnus-group-mode)
							  (mode . gnus-summary-mode)
							  (mode . gnus-article-mode)
							  (name . ,(rx bos ".bbdb" eos))
							  (name . ,(rx bos ".newsrc-dribble")))))))
		 :hook ((ibuffer . (lambda () (ibuffer-switch-to-saved-filter-groups "default")))
				(ibuffer . ibuffer-auto-mode))
		 :bind ("C-x C-b" . ibuffer))
	 #+END_SRC

	 Ibuffer has turned out to be quite a nifty alternative to
	 =list-buffers=. Not only does it support filter-groups, as presented
	 here, but buffers can be filtered by modes, content or miscellaneous
	 attributes. This presents itself as very helpful, when managing a
	 large amount (more than 100) of buffer.

**** Window Management
	 #+BEGIN_SRC emacs-lisp
	   (use-package winner
		 :demand
		 :config
		 (setq winner-dont-bind-my-keys t)
		 (winner-mode)
		 :bind (:map winner-mode-map
					 ("C-c <right>" . nil)
					 ("C-c <left>" . nil)
					 ("C-x <down>" . winner-undo)
					 ("C-x <up>" . winner-redo)))
	 #+END_SRC

	 The =winner-mode= global mode lets it's user easily recreate previous
	 window configurations, similarly to regular undo'ing in buffers. I
	 don't use the default =C-c <right>= and =C-c <left>= configuration,
	 since this conflicts with my muscle memory for flycheck's
	 next/previous error, so I use rebound the keys.

*** OS Management and Tools
**** Directory Managment
	 #+BEGIN_SRC emacs-lisp
	   (require 'dired)
	   (require 'dired-x)

	   (setq dired-dwim-target t
			 dired-recursive-copies 'always
			 dired-recursive-deletes 'top
			 dired-ls-F-marks-symlinks t
			 dired-ls-sorting-switches "v"
			 dired-omit-files-p nil
			 dired-listing-switches "-NABhl --group-directories-first")
	   (add-to-list 'dired-guess-shell-alist-user
					`(,(rx "." (or "epub" "pdf") eos) "mupdf"))
	   (add-to-list 'dired-guess-shell-alist-user
					`(,(rx "." (or "png" "jpg" "jpeg") eos) "feh"))
	   (add-to-list 'dired-guess-shell-alist-user
					`(,(rx "." (or "mp4" "webm" "m4a") eos) "mpv --really-quiet"))
	   (add-hook 'dired-mode-hook 'auto-revert-mode)
	 #+END_SRC

	 Not much to say: For the most part, a under-customized dired
	 configuration.

	 #+BEGIN_SRC emacs-lisp
	   (setq wdired-allow-to-change-permissions t
			 wdired-allow-to-redirect-links t)
	 #+END_SRC

	 Wdired by default only allows one to edit file names. Setting these
	 variables, extends the abilities of this very interesting minor
	 mode.

**** Integrated Shell
	 #+BEGIN_SRC emacs-lisp
	   (setq-default eshell-banner-message ""
					 eshell-prompt-function (lambda (&rest _) "$ ")
					 eshell-prompt-regexp "^$ ")
	 #+END_SRC

	 Eshell works quite well out of the box, all I want is to turn off
	 the banner and simplify the prompt.

**** Terminal Emulation
	 #+BEGIN_SRC emacs-lisp
	   (setq explicit-shell-file-name (executable-find "sh"))
	 #+END_SRC

	 Use =sh= instead of =bash= as the =term= subshell.

	 #+BEGIN_SRC emacs-lisp
	   (advice-add 'term-handle-exit :after
				   (lambda (&rest _)
					 (kill-buffer (current-buffer))))
	 #+END_SRC

	 Don't keep the buffer around as soon as the process ends.

*** Networking
**** Mail
***** Gnus
	  #+BEGIN_SRC emacs-lisp
		(use-package gnus
		  :if (and (executable-find "mpop")
				   (executable-find "msmtp"))
		  :config
		  (require 'bbdb)
      #+END_SRC

	  Gnus will be configured, only if =mpop= and =msmtp= (see below) are
	  found as executable.

	  #+BEGIN_SRC emacs-lisp
		(setq message-directory "~/etc/mail/"
			  gnus-directory "~/etc/news/")
	  #+END_SRC

	  Before anything happens, I specify my directories in accordance
	  to [[*Short%20note%20on%20my%20directory%20structure]["Short note on my directory structure"]].

	  #+BEGIN_SRC emacs-lisp
		(setq gnus-use-full-window nil
			  gnus-novice-user nil
			  gnus-expert-user t)
	  #+END_SRC

	  =gnus-use-full-window= prevents Gnus from disturbing my current
	  window setup, and instead tries to just use the current window.

	  The last two options make sure that Gnus doesn't have to prompt me
	  all the time. Note that their names doesn't reflect the actual
	  abilities of the user.

	  #+BEGIN_SRC emacs-lisp
		(setq gnus-select-method '(nnmaildir "mail"
											 (directory "~/etc/mail/")
											 (nnir-search-engine notmuch)))
	  #+END_SRC

	  I have two accounts I use (personal and university Email), and bot
	  are synchronized via [[https://marlam.de/mpop/][mpop]], my [[https://zge.us.to/files/scripts/authinfo][authinfo]] script and the following
	  configuration:

	  #+INCLUDE: "~/.mpoprc" src conf-space :tangle no

	  I end up with two directories in =~/etc/mail= (=pers= and =uni= in my
	  case) that are both recognized as such by gnus.

	  #+BEGIN_SRC emacs-lisp
		(defvar zge/mail-string "")

		(defun zge/mail-from (file)
		  (interactive "f")
		  (with-current-buffer (find-file-noselect file)
			(goto-char (point-min))
			(when (search-forward-regexp (rx bol "From: ") nil t)
			  (buffer-substring-no-properties (point) (point-at-eol)))))

		(defun zge/format-mail (name)
		  (let* ((dir-name (concat "~/etc/mail/" name "/new"))
				 (dir (cddr (directory-files dir-name)))
				 (from-list (mapconcat #'zge/mail-from dir ",")))
			(and dir
				 (propertize (format "%s %d" name (length dir))
							 'mouse-face 'highlight
							 'help-echo from-list))))

		(defun zge/format-mail-string (&rest _)
		  (let ((pers (zge/format-mail "pers"))
				(uni (zge/format-mail "uni")))
			(setq zge/mail-string
				  (cond ((and pers uni)
						 (concat " Mail: " pers ", " uni))
						(pers (concat " Mail: " pers))
						(uni (concat " Mail: " uni))
						(t "")))))

		(defun zge/fetch-mail ()
		  (interactive)
		  (async-start (lambda ()
						 (shell-command "mpop -aQ")
						 (when (executable-find "notmuch")
						   (shell-command "notmuch new")))
					   #'zge/format-mail-string))
		(defalias 'fetch-mail 'zge/fetch-mail)

		(run-at-time nil (* 60 10) #'zge/fetch-mail)
		(add-to-list 'global-mode-string 'zge/mail-string t)
		(advice-add 'gnus :after #'zge/format-mail-string)
	  #+END_SRC

	  Mpop should then be called every 10 minutes, in a asynchronous
	  process. This can also be manually done by calling =fetch-mail=.

	  #+BEGIN_SRC emacs-lisp
		(setq gnus-posting-styles
			  `((".*" (signature-file "~/.signature"))
				("uni"
				 (address ,(rot13-string "cuvyvc.xnyhqrepvp@snh.qr"))
				 (name ,(rot13-string "Cuvyvc Xnyhqrepvp"))
				 (signature-file "~/.uni-signature"))))
	  #+END_SRC

	  Additionally, I add the following "posting styles" (ie. what to
	  append to the end of a message):

      #+BEGIN_SRC emacs-lisp
		(setq gnus-summary-line-format "%U%R │ %d% │ %4k: %4{%-23,23F%} │%(%B%S%)\n"
			  gnus-sum-thread-tree-single-indent    "   "
			  gnus-sum-thread-tree-false-root       "   "
			  gnus-sum-thread-tree-root             "┌  "
			  gnus-sum-thread-tree-vertical         "│  "
			  gnus-sum-thread-tree-leaf-with-other  "├→ "
			  gnus-sum-thread-tree-single-leaf      "└→ "
			  gnus-sum-thread-tree-indent           "   ")
		(advice-add 'gnus-group-select-group :after #'end-of-buffer)
	  #+END_SRC

	  To make the default summaries a bit easier to parse and read, I
	  have changed the default column formatting and made
	  tree-formatting look better using some Unicode.

	  The group buffer line format has also been changed, to discard
	  information I don't need, since /topic mode/ is turned on.

	  #+BEGIN_SRC emacs-lisp
		(setq gnus-thread-sort-functions '(gnus-thread-sort-by-number))
	  #+END_SRC

	  Generally, I don't use Gnus' scoring system. Everything I care
	  about is the temporal order in which I received messages,
	  ie. their "number".

	  #+BEGIN_SRC emacs-lisp
		(setq gnus-treat-from-gravatar 'head
			  gnus-treat-mail-gravatar 'head)
	  #+END_SRC

	  For no other reason than personal preference, I enable [[https://en.wikipedia.org/wiki/Gravatar][Gravatar]].

	  #+BEGIN_SRC emacs-lisp
		(setq mm-discouraged-alternatives '("text/html" "text/richtext"))
	  #+END_SRC

	  There is no reason to prefer HTML mail (at least for me), since it
	  just makes it harder and more complicated to display properly and
	  good readability. Hence I'll try to avoid these, if possible.

	  #+BEGIN_SRC emacs-lisp
		(setq mm-inline-large-images t)
	  #+END_SRC

	  By default Gnus wants to use external tools to open "larger"
	  images, when they're attached to a mail. Since I don't need this,
	  I force inline opening in all cases.

      #+BEGIN_SRC emacs-lisp
		(setq mml-secure-openpgp-signers (list user-mail-address)
			  mml-secure-openpgp-encrypt-to-self t
			  mm-verify-option 'known
			  mm-decrypt-option 'known
			  gnus-message-replyencrypt t
			  gnus-buttonized-mime-types '("multipart/signed"))

		(add-hook 'message-send-hook #'mml-secure-message-sign-pgpmime)
	  #+END_SRC

	  Setup Gnus' encryption, signing and verification system.

	  #+BEGIN_SRC emacs-lisp
		(setq epa-pinentry-mode 'loopback)
	  #+END_SRC

	  Since my =.authsource= is encrypted, I have to enter my password from
	  time to time to access my mail. This also requires
	  =~/.gnupg/.gpg-agent.conf= to contain the following two lines,

	  #+INCLUDE: "~/.gnupg/gpg-agent.conf" src conf :tangle no

	  so that "pintetry" is used for query my paraphrase.

	  #+BEGIN_SRC emacs-lisp
		(setq nnir-notmuch-remove-prefix (expand-file-name "~/etc/mail/"))
	  #+END_SRC

	  As configured above, I use [[https://notmuchmail.org/][notmuch]] to index and search (=G G=) my
	  mail. But if the above variable is not correctly set, no results
	  will be found.

	  #+BEGIN_SRC emacs-lisp
		(setq gnus-gcc-mark-as-read t)
	  #+END_SRC

	  Send messages are archived locally, but unless this variable is
	  non-nil, will always appear as "unread", which doesn't make a lot
	  of sense (to me).

	  #+BEGIN_SRC emacs-lisp
		:bind (("C-x x m" . gnus)))
	  #+END_SRC

	  Finally keybindings are set up.

***** SMTP
	  #+BEGIN_SRC emacs-lisp
		(with-eval-after-load 'message
		  (setq message-send-mail-function #'message-send-mail-with-sendmail
				message-sendmail-extra-arguments '("--read-envelope-from")
				message-sendmail-f-is-evil t
				message-sendmail-envelope-from 'header
				message-kill-buffer-on-exit t
				message-forward-as-mime t
				mail-user-agent 'gnus-user-agent
				sendmail-program (executable-find "msmtp"))
	  #+END_SRC

	  Instead of using Emacs' internal SMTP service, I use [[https://marlam.de/msmtp/][msmtp]], simply
	  for the sake of speed. Additionally, this setup automatically
	  chooses what server to contact, based on the =From:= field.

	  My msmtp configuration is as follows:

	  #+INCLUDE: "~/.msmtprc" src conf-space :tangle no

	  As already mentioned, this requires a [[https://zge.us.to/files/scripts/authinfo][special script]] I wrote to
	  extract password-data from =~/.authinfo.gpg=.

	  #+BEGIN_SRC emacs-lisp
		(add-hook 'message-mode-hook #'turn-on-orgstruct++)
		(add-hook 'message-mode-hook #'turn-on-orgtbl))
	  #+END_SRC

	  Furthermore, =orgstruct= is enabled to help writing and structuring
	  emails similarly to =org-mode= buffers.

***** BBDB
	  #+BEGIN_SRC emacs-lisp
		(use-package bbdb
		  :after gnus
		  :config
		  (setq bbdb-mua-auto-update-p nil
				bbdb-mua-update-interactive-p '(query . create)
				bbdb-complete-mail-allow-cycling t
				bbdb-use-pop-up nil
				bbdb-completion-display-record nil
				bbdb-message-all-addresses t
				bbdb-file (expand-file-name "bbdb" user-emacs-directory))
		  (bbdb-initialize 'gnus 'message 'pgp)
		  (bbdb-mua-auto-update-init 'message)
		  :bind (("C-x x b" . bbdb)
				 ("C-x x B" . bbdb-create)
				 :map gnus-summary-mode-map
				 (";" . bbdb-mua-edit-field)))
	  #+END_SRC

	  Install and setup /BBDB/ (Insidious Big Brother Database) for contact
	  management, and enable completion in message buffers.

**** IRC
	 #+BEGIN_SRC emacs-lisp
	   (use-package rcirc
		 :commands (rcirc-update-activity-string)
		 :config
		 (setq rcirc-server-alist
			   `(("zge.us.to"
				  :user-name "zge"
				  :nick "zge"
				  :password ,zge/znc-pass
				  :port 23551
				  :encryption tls))
			   rcirc-reconnect-delay 12
			   rcirc-omit-responses '("NICK" "AWAY"))
		 (advice-add 'rcirc-abbreviate
					 :override #'identity)
		 (advice-add 'rcirc-next-active-buffer
					 :after (lambda (&rest _)
							  (rcirc-update-activity-string)))
		 :hook ((rcirc-mode . flyspell-mode)
				(rcirc-mode . electric-pair-local-mode)
				(rcirc-mode . rcirc-track-minor-mode))
		 :bind (("C-x x x" . rcirc-next-active-buffer)
				:map rcirc-mode-map
				("C-x k" . bury-buffer)))
	 #+END_SRC

	 For IRC, I use rcirc The =zge/znc-pass= variables is declared in my
	 [[*Emacs-generated files][=custom.el=]] file.

**** Feed Syndication
	 #+BEGIN_SRC emacs-lisp
	   (use-package elfeed
		 :config
		 (setq elfeed-search-filter "@1-month-ago +unread"
			   elfeed-db-directory "~/.local/share/elfeed")
		 :bind ("C-x x f" . elfeed))
	 #+END_SRC

	 My newsreader is even in Emacs! What a supp rise. Elfeed almost
	 certainly the most popular package for this task, and I can highly
	 recommend it, especially if ones gets a bit bored in between doing
	 "work".

	 My =elfeed-feeds= variable isn't specified here, but it's kept in my
	 =custom.el= file.

**** Browser
	 #+BEGIN_SRC emacs-lisp
	   (setq-default browse-url-browser-function 'browse-url-firefox
					 eww-download-directory (expand-file-name "~/dl")
					 eww-search-prefix "https://duckduckgo.com/lite/?q="
					 shr-use-colors nil)
	 #+END_SRC

	 Use whatever is set as the default browser on the current system,
	 when opening =http://= links. (But still let =eww= be properly
	 configured.) Additionally, the contrast is increased to make
	 webpages (and HTML emails) with peculiar background colors render
	 better.

**** Translation
	 #+BEGIN_SRC emacs-lisp
	   (use-package google-translate
		 :config
		 (setq google-translate-show-phonetic t
			   google-translate-default-source-language "en"
			   google-translate-default-target-language "de")
		 :bind (("C-c t t" . google-translate-at-point)
				("C-c t T" . google-translate-at-point-reverse)
				("C-c t q" . google-translate-query-translate)
				("C-c t Q" . google-translate-query-translate-reverse)))
	 #+END_SRC

	 When translating or writing texts, this package shows itself to be
	 quite helpful, when I can't thing of a word.

*** General Tools and Programs
**** Spell Checking
	 #+BEGIN_SRC emacs-lisp
	   (setq-default ispell-program-name (executable-find "aspell")
					 ispell-extra-args '("--sug-mode=normal" "--keyboard=standard")
					 ispell-local-dictionary-alist
					 '(("german-new8" "[[:alpha:]]" "[^[:alpha:]]"
						"[']" t ("-d" "de_DE") nil utf-8)
					   ("british" "[[:alpha:]]" "[^[:alpha:]]"
						"[']" t ("-d" "en_GB") nil utf-8))
					 flyspell-issue-welcome-flag nil
					 flyspell-issue-message-flag nil
					 flyspell-use-meta-tab nil)
	 #+END_SRC

	 When just writing prose, or just comments, =flyspell-mode= (and
	 =flyspell-prog-mode=) prove themselves to be valuable utilities,
	 albeit a bit slow and cumbersome from time to time...

**** RPN Calculator
	 #+BEGIN_SRC emacs-lisp
	   (setq-default calc-angle-mode 'rad
					 calc-shift-prefix t
					 calc-infinite-mode t
					 calc-vector-brackets nil
					 calc-vector-commas nil
					 calc-matrix-just 'right
					 calc-matrix-brackets '(R O)
					 calc-complex-format 'i)
	 #+END_SRC

	 I have grown fond of Emacs Calc, even though it might is be big
	 complicated to go beyond the basics. Most of these options have been
	 taken from the auto generated =calc.el= file.

**** Accounting
	 #+BEGIN_SRC emacs-lisp
	   (use-package ledger-mode
		 :if (executable-find "ledger")
		 :config
		 (setq ledger-source-directory (expand-file-name "~/doc/ledger")
			   ledger-reconcile-default-commodity "EUR"
			   ledger-highlight-xact-under-point nil
			   ledger-master-file (expand-file-name "master.lg" ledger-source-directory)
			   ledger-use-iso-dates t)
		 :mode ((rx ".lg" eos) . ledger-mode))
	 #+END_SRC

	 In an effort to use ledger, I have set up =ledger-mode= with some
	 sane defaults.

**** PDF Viewer
	 #+BEGIN_SRC emacs-lisp
	   (use-package pdf-tools
		 :if window-system
		 :config
		 (setq pdf-view-display-size 'fit-page)
		 (pdf-tools-install)
		 :mode ((rx ".pdf" eos) . pdf-view-mode)
		 :magic ("%PDF-" . pdf-view-mode)
		 :bind (:map pdf-view-mode-map
					 ("c" . pdf-annot-add-text-annotation)))
	 #+END_SRC

	 Adding PDF-Tools let's me use emacs properly for opening PDFs,
	 making me less dependant on external tools and window managers.

** Programming
*** Text Editing
**** LaTeX
	 #+BEGIN_SRC emacs-lisp
	   (use-package latex
		 :ensure auctex
		 :if (or (executable-find "pdflatex")
				 (executable-find "xelatex"))
		 :defines (LaTeX-electric-left-right-brace
				   preview-auto-cache-preamble electric-pair-inhibit-predicate
				   TeX-view-program-selection TeX-parse-self TeX-master
				   TeX-source-correlate-start-server TeX-revert-document-buffer
				   TeX-auto-save reftex-plug-into-AUCTeX reftex-enable-partial-scans)
		 :config
		 (setq-default TeX-master 'dwim)
		 (setf (alist-get 'output-pdf TeX-view-program-selection) '("PDF Tools")
			   TeX-auto-save t
			   TeX-parse-self t
			   TeX-PDF-mode t
			   preview-auto-cache-preamble t
			   reftex-plug-into-AUCTeX t
			   reftex-enable-partial-scans t)
		 (add-hook 'LaTeX-language-de-hook (lambda () (zge/toggle-dictionary "de")))
		 (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
		 (add-hook 'LaTeX-mode-hook (setl electric-pair-inhibit-predicate #'ignore))
		 :hook ((LaTeX-mode . flycheck-mode)
				(LaTeX-mode . reftex-mode)
				(LaTeX-mode . TeX-fold-mode))
		 :mode ((rx ".tex" eos) . TeX-latex-mode))
	 #+END_SRC

	 Installing AucTeX is a bit wierd, since it doesn't quite fit the
	 =use-package= paradigm. Most changes I make, are quite standard, the
	 only noteworthy points are:
	 - Use [[*PDF Viewer][=pdf-tools=]] instead of an external (usually Evience) viewer
	 - Let =electric-pair-mode= delete adjacent parentheses, but *don't*
       insert any. Why? Because that will make cdlatex a lot easier to
       configure.
	 - If AucTeX recognizes the document to be German, call my [[*Toggle dictionary][language
       toggle function]].
	 - Don't bother installing anything, if no latex compiler is found.

	 #+BEGIN_SRC emacs-lisp
	   (use-package cdlatex
		 :after auctex
		 :config
		 (setq cdlatex-paired-parens "$[{(")
		 (add-to-list 'cdlatex-math-modify-alist
					  '(?B "\\mathbb" nil t nil nil))
		 (add-to-list 'cdlatex-math-modify-alist
					  '(?F "\\mathfrak" nil t nil nil))
		 (add-to-list 'cdlatex-math-symbol-alist
					  '(?# ("\\equiv")))
		 (add-to-list 'cdlatex-command-alist
					  '("eq" "Insert \\[ \\] pair"
						"\\[ ? \\]" cdlatex-position-cursor nil t nil))
		 :hook (LaTeX-mode . cdlatex-mode))
	 #+END_SRC

	 Additionally, CDLaTeX provides a more comfortable input and
	 intuitive automation, where possible. I extend the tables by a few
	 commands that I like to use more often, as to make working with TeX
	 more comfortable. Note that these changes will also take effect in
	 my [[*Org][Org]] configuration.

**** Org
	 #+BEGIN_SRC emacs-lisp
	   (use-package org
		 :defines (org-html-mathjax-options)
		 :commands (org-next-link
					org-previous-link
					turn-on-org-cdlatex
					org-babel-do-load-languages)
		 :config
		 (require 'org-agenda)
	 #+END_SRC

	 The following configuration is wrapped in a =use-package= macro...

	 #+BEGIN_SRC emacs-lisp
	   (setq org-use-speed-commands t
			 org-hide-emphasis-markers t
			 org-yank-adjusted-subtrees t
			 org-startup-folded nil
			 org-return-follows-link t
			 org-highlight-latex-and-related '(latex entities)
			 org-M-RET-may-split-line '((default))
			 org-special-ctrl-a/e t
			 org-special-ctrl-k t)
	 #+END_SRC

	 Basic stylistic and movment options (especially enabling using the
	 shift key to mark a region).

	 #+BEGIN_SRC emacs-lisp
	   (setq org-fontify-whole-heading-line t
			 org-fontify-quote-and-verse-blocks nil
			 org-src-fontify-natively t
			 org-src-tab-acts-natively t
			 org-src-window-setup 'current-window)
	 #+END_SRC

	 Especially this document uses a lot of source blocks, so
	 highlighting and indenting them appropriately is very convenient.

	 #+BEGIN_SRC emacs-lisp
	   (setq org-directory (expand-file-name "~/doc/org/")
			 org-agenda-files (mapcar (lambda (f) (expand-file-name
												   (concat org-directory f ".org")))
									  '("ws18" "pers" "notes"))
			 org-agenda-include-diary t
			 org-agenda-inhibit-startup t
			 org-agenda-window-setup 'current-window
			 org-default-notes-file (expand-file-name "notes.org" org-directory))

	 #+END_SRC

	 Within my documents directory (=~/doc/=) I have an =org= directory just
	 for org files, which I notify =org-mode= of. Furthermore, I inform Org
	 about my notes and agenda file.

	 #+BEGIN_SRC emacs-lisp
	   (setq org-capture-templates
			 `(("a" "Appointment" entry (file+headline "pers.org" "Appointments")
				"* %^t %?\n")
			   ("p" "Plans" entry (file+headline "pers.org" "Plans")
				"* %^t %?\n")
			   ("t" "Todo" entry (file+headline "pers.org" "Todo")
				"* TODO %?\n%i")
			   ("c" "Note" plain (file+olp+datetree ,org-default-notes-file)
				"* %?\n  Entered on %t")
			   ("l" "Link" entry (file+olp+datetree ,org-default-notes-file)
				"* %?\n\ %^L\n  Entered on %U")
			   ("j" "Journal" entry (file+datetree "journal.org.gpg")
				"* Entered on %U\n %i")))
	 #+END_SRC

	 Having special /capture templates/ will probably help in getting used
	 to using org-mode for taking notes.

	 #+BEGIN_SRC emacs-lisp
	   (setq org-todo-keywords '((sequence "TODO(t)" "WAIT(w)" "NEXT(n)" "DONE(d)")))
	 #+END_SRC

	 Since I don't require a complex TODO setup, I have chosen to keep
	 the default keywords, as one often finds them recommended.

	 #+BEGIN_SRC emacs-lisp
	   (setq org-export-date-timestamp-format "%X"
			 org-html-metadata-timestamp-format "%X"
			 org-export-backends '(ascii beamer html latex md)
			 org-export-dispatch-use-expert-ui t)
	 #+END_SRC

	 General export settings

	 #+BEGIN_SRC emacs-lisp
	   (setq org-html-doctype "xhtml5"
			 org-html-html5-fancy t
			 org-latex-listings 'minted
			 org-latex-pdf-process
			 '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
			   "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
			   "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")
			 org-latex-packages-alist '(("" "microtype" nil)
										("" "babel" nil)
										("" "minted" nil)
										("" "lmodern" nil)))
	 #+END_SRC


	 By default, exporting to LaTeX would produce visually unpleasing
	 code. But by enabling [[https://www.ctan.org/texarchive/macros/latex/contrib/minted][minted]], this issue is mitigated quite easily.

	 Furthermore, a few extra default packages are added, which I always
	 enable.

	 #+BEGIN_SRC emacs-lisp
	   (dolist (hook (list #'flyspell-prog-mode
						   #'turn-on-org-cdlatex))
		 (add-hook 'org-mode-hook hook))
	 #+END_SRC

	 Default =flyspell-mode= complains about terms such as ~#+BEGIN_SRC~,
	 but =flyspell-prog-mode= is intelligent enough to ignore these, make
	 sure the former is turned off, while the latter is activated (it's
	 activated in the first place because =org-mode= inherits =text-mode='s
	 hooks).

	 #+BEGIN_SRC emacs-lisp
	   (setq org-clock-into-drawer t
			 org-clock-continuously t
			 org-log-into-drawer t)
	 #+END_SRC

	 Configure org-mode clocking and logging.

	 #+BEGIN_SRC emacs-lisp
	   (setq org-confirm-babel-evaluate nil)

	   (org-babel-do-load-languages
		'org-babel-load-languages
		'((emacs-lisp . nil)
		  (C . t) (python . t) (scheme . t)
		  (dot . t) (sqlite . t) (calc . t)
		  (java . t) (awk . t) (ditaa . t)
		  (haskell . t) (lisp . t)))
	 #+END_SRC

	 Load languages for [[info:org#Library%20of%20Babel][Org Babel]], without the need to reconfirm.

	 #+BEGIN_SRC emacs-lisp
	   (with-eval-after-load 'ox-html
		 (setq org-html-mathjax-template
			   "<link rel=\"stylesheet\"
					  href=\"https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css\"
					  integrity=\"sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y\"
					  crossorigin=\"anonymous\"/>
				<script defer=\"defer\"
						src=\"https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js\"
						integrity=\"sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx\"
						crossorigin=\"anonymous\"></script>
			   <script defer=\"defer\"
					   src=\"https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js\"
					   integrity=\"sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe\"
					   crossorigin=\"anonymous\"
					   onload=\"renderMathInElement(document.body);\"></script>"))
	 #+END_SRC

	 Setup KaTeX as compared to the default MathJax. Code from [[https://amitp.blogspot.com/2019/02/emacs-org-mode-and-katex.html][here]].

     #+BEGIN_SRC emacs-lisp
	   (add-to-list 'org-structure-template-alist
					'("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"
					  "<src lang=\"emacs-lisp\">\n\n</src>"))
     #+END_SRC

     Adding this code to =org-structure-template-alist=, makes it easier
     to maintain files like these, since expands =<E= to a source block
     with emacs-lisp automatically chosen as the language. Due to a
     org-mode bug, this has to be evaluated after the document has been
     loaded.

     #+BEGIN_SRC emacs-lisp
	   (setq org-preview-latex-image-directory "/tmp/ltxpng/")
	   (plist-put org-format-latex-options :scale 1.5)
     #+END_SRC

     LaTeX previews can be a bit small and clutter the working
     directory, so the following options should migrate these issues.

	 #+BEGIN_SRC emacs-lisp
	   (setf (alist-get 'file org-link-frame-setup) #'find-file)
	 #+END_SRC

	 Open links in the current frame.

	 #+BEGIN_SRC emacs-lisp
	   (add-to-list 'org-show-context-detail
					'(org-goto . local))
	 #+END_SRC

	 When jumping around a org-document (or using =counsel-org-goto-all=)
	 this setting makes sure that the part of the document I just jumped
	 to is visible, and doesn't have to be opened again manually.


     #+BEGIN_SRC emacs-lisp
	   :bind (("C-c c" . org-capture)
			  ("C-c a" . org-agenda)
			  ("C-c l" . org-store-link)
			  :map org-agenda-mode-map
			  ("<tab>" . org-next-link)
			  ("<S-iso-lefttab>" . org-previous-link)))
     #+END_SRC

     Here I set a few convenient keybindings for globally interacting
     with my org ecosystem.

     Also: [[*Spell Checking][Spell Checking]] sadly shadows org's auto-complete functionality,
     with an alternative I never use. When instead re-binding =pcomplete=,
     one get's a lot more out of Org, without having to look up
     everyhing in the manual.

**** Markdown
     #+BEGIN_SRC emacs-lisp
	   (use-package markdown-mode
		 :if (executable-find "cmark")
		 :config
		 (setq markdown-italic-underscore t
			   markdown-command "cmark")
		 :mode (rx (or (seq bos "README" (opt ".md"))
					   (or ".markdown" ".mkdn" ".md"))
				   eos))
     #+END_SRC

	 Markdown is probably one of the most popular markup languages around
	 nowadays, and tools like [[https://pandoc.org/][Pandoc]] really bring out it's inner
	 potential (or rather create it in the first place). =Markdown-mode=
	 offers nice support for quite a few Pandoc features, so it's usually
	 my default choice when I have to work with medium to longer sized
	 documents.

	 For simple previews, I've set [[https://kristaps.bsd.lv/lowdown][lowdown]] as my markdown processor, due
	 to it's speed (as compared to =markdown.pl= or Pandoc).

*** Programming Languages
**** C
     #+BEGIN_SRC emacs-lisp
	   (with-eval-after-load 'cc-mode
		 (setf (alist-get 'other c-default-style) "k&r"
			   c-delete-function #'backward-delete-char
			   c-delete-function #'delete-char)
	 #+END_SRC

	 From what one can see, it is obvious that I still have to get around
	 to properly set up my C editing environment.

	 #+BEGIN_SRC emacs-lisp
	   (define-key c-mode-map (kbd "C-c C-k") #'compile))
	 #+END_SRC

	 I'm used to =C-c C-k= for compiling, but c-mode disagrees.

	 #+BEGIN_SRC emacs-lisp
	   (setq gdb-display-io-nopopup t
			 gdb-show-main t
			 gdb-enable-debug t
			 gdb-many-windows t)
	 #+END_SRC

	 Currently my only option is to disable a "dedicated" I/O buffer,
	 when running a debugger.

**** Gnuplot
	 #+BEGIN_SRC emacs-lisp
	   (use-package gnuplot
		 :if (executable-find "gnuplot")
		 :interpreter ("gnuplot" . gnuplot-mode)
		 :functions (gnuplot-send-string-to-gnuplot)
		 :config
		 (defun zge/gnuplot-replot ()
		   (interactive)
		   (gnuplot-send-string-to-gnuplot "replot\n" 'line))
		 :mode ((rx ".gp" eos) . gnuplot-mode)
		 :bind (:map gnuplot-mode-map
					 ("C-c C-c" . zge/gnuplot-replot)))
	 #+END_SRC

	 =gnuplot= [sic] has been my go-to plotter for a few years now. Most
	 of the time I use it in it's REPL, but especially when working with
	 scripts, =gnuplot-mode= proves itself to be helpful.

	 Due to the wierd package name, and the fact that I use =.gp= as the
	 file extention for gnuplot files, as few things have to be
	 re-aliased for the mode to work properly.

**** HTML
	  #+BEGIN_SRC emacs-lisp
		(setq sgml-xml-mode t
			  skeleton-end-newline nil)
	  #+END_SRC

	  For most of what I do, Emacs' built in =mhtml-mode=. The only major
	  annoyance is it's default insistence not to close some tags (=<p>=,
	  =<dl>/<dd>=, ...), which I here prevent. Furthermore, when inserting
	  a html tag with =sgml-tag= (=C-c C-o=), don't add unnecessary
	  newlines.

**** Go
	 #+BEGIN_SRC emacs-lisp
	   (use-package go-mode
		 :if (executable-find "go")
		 :init
		 (add-hook 'go-mode-hook
				   (setl compile-command
						 "go generate && go build -v && go test -v && go vet"))
		 (add-hook 'go-mode-hook
				   (lambda () (add-hook 'before-save-hook
										#'gofmt-before-save t t)))
		 :config
		 (setq gofmt-command "goimports")
		 (let* ((go-path  "/home/phi/code/go")
				(go-bin (expand-file-name "bin" go-path)))
		   (setenv "GOPATH" go-path)
		   (add-to-PATH go-bin))
		 :mode (rx ".go" eos)
		 :bind (:map go-mode-map
					 ("M-." . godef-jump)
					 ("C-c ." . godoc-at-point)
					 ("C-c C-r" . go-remove-unused-imports)))

	   (use-package company-go
		 :after (go-mode company)
		 :init
		 (add-hook 'go-mode-hook (setl company-backends '(company-go))))

	   (use-package go-eldoc
		 :after go-mode
		 :hook (go-mode . go-eldoc-setup))
	 #+END_SRC

	 Go can be very fragile, but after having have set up the right files
	 and installed the right extensions, my setup gives a fairly smooth
	 editing experience.

	 Currently, the following packages are installed
	 - [[https://github.com/mdempsky/gocode][gocode]]
	 - [[https://github.com/rogpeppe/godef][godef]]
	 - [[https://golang.org/x/tools/cmd/goimports][goimports]]

**** Rust
	 #+BEGIN_SRC emacs-lisp
	   (use-package rust-mode
		 :if (file-exists-p "~/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/")
		 :config
		 (setq rust-format-on-save t)
		 (let* ((rust-dir "~/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/")
				(rust-bin (expand-file-name "bin" rust-dir))
				(rust-src (expand-file-name "lib/rustlib/src/rust/src/" rust-dir)))
		   (setenv "RUST_SRC_PATH" rust-src)
		   (add-to-PATH rust-bin))
		 :mode (rx ".rs" eos))
	 #+END_SRC

	 When playing around with Rust, having a Emacs mode installed is
	 convenient.

	 Currently I have to install Rust via =rustup=, but I hope that will
	 change in the future. Via cargo I install:
	 - [[https://github.com/rust-lang/rustfmt][rustfmt]]
	 - [[https://github.com/rust-lang/rust-clippy][clippy]]
	 - [[https://github.com/racer-rust/racer][racer]]

	 #+BEGIN_SRC emacs-lisp
	   (use-package cargo
		 :after rust-mode
		 :hook (rust-mode . cargo-minor-mode))

	   (use-package racer
		 :after rust-mode
		 :hook (rust-mode . racer-mode))
	 #+END_SRC

	 Additionally, /cargo/ and /racer/ are lazily loaded, as soon as rust is
	 required.

**** Scheme
	 #+BEGIN_SRC emacs-lisp
	   (use-package geiser
		 :if (executable-find "guile")
		 :config
		 (setq geiser-repl-use-other-window nil
			   geiser-active-implementations '(guile))
		 :hook (scheme-mode . geiser-mode)
		 :interpreter ("guile" . scheme-mode)
		 :mode ((rx ".scm" eos) . scheme-mode))
	 #+END_SRC

	 When properly set up, geiser gives an MIT Scheme-like editing
	 experience. It's not perfect, and it sometimes drags the whole
	 editor down, but for the amount of Scheme programming I do it's
	 entirely sufficient.

**** Common Lisp
	 #+BEGIN_SRC emacs-lisp
	   (use-package slime
		 :if (executable-find "sbcl")
		 :after paredit
		 :init
		 (add-hook 'common-lisp-mode-hook
				   (setl lisp-indent-function 'common-lisp-indent-function))
		 :config
		 (setq inferior-lisp-program (executable-find "sbcl")
			   slime-completion-at-point-functions '(slime-fuzzy-complete-symbol)
			   slime-contribs '(slime-autodoc slime-cl-indent slime-fuzzy))
		 (let ((core (expand-file-name "sbcl.core-for-slime" user-emacs-directory)))
		   (when (file-exists-p core)
			 (setf (alist-get 'sbcl slime-lisp-implementations)
				   `(("sbcl" "--core" ,core)))))
		 (company-mode -1)
		 :bind (:map slime-mode-map ("C-#" . slime-selector))
		 :interpreter ("sbcl" . common-lisp-mode)
		 :mode (((rx ".lisp" eos) . common-lisp-mode)
				((rx ".cl" eos) . common-lisp-mode)))
	 #+END_SRC

	 Since Elisp and Common Lisp share a common ancestry in Maclisp and
	 Franzlisp (more so that Scheme), it should be worthwhile to learn
	 CL. Additionally, the =cl= library for Emacs seems to be quite popular
	 -- and what better place to learn Common Lisp than in Emacs itself
	 with the popular SLIME (The Superior Lisp Interaction Mode for
	 Emacs) environment?

**** Haskell
	 #+BEGIN_SRC emacs-lisp
	   (use-package haskell-mode
		 :if (executable-find "ghc")
		 :after company-ghc
		 :hook ((haskell-mode . haskell-doc-mode)
				(haskell-mode . (lambda () (yas-minor-mode -1))))
		 :interpreter "ghc"
		 :mode (rx ".hs" eos))
	 #+END_SRC

	 Programming Haskell can be a very nice experience in Emacs, but as
	 always, it has to be properly set up.

	 #+BEGIN_SRC emacs-lisp
	   (use-package company-ghc
		 :after company
		 :init
		 (add-hook 'haskell-mode-hook (setl company-backends '(company-ghc))))
	 #+END_SRC

	 For improved interaction, intelligent and informative auto
	 completion is always appreciated.

**** Idris
	 #+BEGIN_SRC emacs-lisp
	   (use-package idris-mode
		 :if (executable-find "idris")
		 :config
		 (setq idris-stay-in-current-window-on-compiler-error t
			   idris-prover-restore-window-configuration t)
		 :interpreter "idris"
		 :mode (rx ".idr" eos))
	 #+END_SRC

	 Next to Haskell, Idris is slightly easier to configure than Haskell
	 but lacks (as of now) company support.

**** Perl
	 #+BEGIN_SRC emacs-lisp
	   (add-hook 'cperl-mode-hook
			(lambda () (setl eldoc-documentation-function
							 (lambda ()
							   (let (cperl-message-on-help-error)
								 (car (cperl-get-help)))))))
	 #+END_SRC

	 As of now, this is my entire perl setup (along with the =defalias=
	 command [[*Aliases][above]]), and for the most purposes, cperl-mode is quite
	 enough.

**** Python
	 #+BEGIN_SRC emacs-lisp
	   (use-package anaconda-mode
		 :if (executable-find "python3")
		 :config
		 (setq python-shell-interpreter "ipython3")
		 :hook ((python-mode .anaconda-mode)
				(python-mode . anaconda-eldoc-mode)))

	   (use-package company-anaconda
		 :after company
		 :init
		 (add-hook 'python-mode-hook
				   (setl company-backends '(company-anaconda)))
		 :config
		 (setq company-anaconda-annotation-function
			   (lambda (cand)
				 (let ((description (get-text-property 0 'description cand)))
				   (when description
					 (concat "<" (substring description 0 1) ">"))))))
	 #+END_SRC

	I keep my Python setup simple but functional, since I don't use Python
	/that/ much, but like to have it working when I do. That means,
	documentation, code exploration and completion should work as
	expected, but other than that, I don't require too much.

**** R
	 #+BEGIN_SRC emacs-lisp
	   (use-package ess
		 :if (executable-find "R")
		 :config
		 (setq ess-fancy-comments nil
			   ess-eval-visibly nil
			   ess-ask-for-ess-directory nil
			   ess-use-company 'script-only))
	 #+END_SRC

	 I don't use R myself currently, but I want to learn it. All
	 configuration options were found in various other configs over the
	 internet, so I can't say how helpful or on they are.

*** Enchantments
**** Viper
	 #+BEGIN_SRC emacs-lisp
	   (setq viper-inhibit-startup-message t
			 viper-expert-level 5)
	 #+END_SRC

	 If I were to want to use Vi keybindings, Viper has me covered (evil
	 is too much). These variables are set to prevent Viper from having
	 to set up everything every time I try to use it.

**** Colorful Parentheses
	 #+BEGIN_SRC emacs-lisp
	   (use-package rainbow-delimiters
		 :after prog-mode
		 :hook (prog-mode . rainbow-delimiters-mode))
	 #+END_SRC

	 Especially when programming Lisp, color-matching parentheses and
	 brackets can help readability. This feature is offered by
	 =rainbow-delemiters=, that I enable in all programming modes.

**** Multiple Cursors
	 #+BEGIN_SRC emacs-lisp
	   (use-package multiple-cursors
		 :bind (("C-<" . mc/mark-previous-like-this)
				("C->" . mc/mark-next-like-this)
				("C-S-n" . mc/mark-next-lines)
				("C-S-p" . mc/mark-previous-lines)
				("C-M-;" . mc/mark-all-like-this-dwim)))
	 #+END_SRC

	 It doesn't take long to adjust to =multiple-cursors-mode=, and it is a
	 feature one turns out to use surprisingly often. While it's not as
	 native or quick, as in other editors (I'm thinking of [[https://github.com/martanne/vis][vis]]), it's for
	 the most part entirely sufficient for my causes.

**** Structural Editing
	 #+BEGIN_SRC emacs-lisp
	   (use-package paredit
		 :diminish
		 :hook ((scheme-mode . paredit-mode)
				(lisp-mode . paredit-mode)
				(emacs-lisp-mode . paredit-mode))
		 :bind (:map paredit-mode-map
					 ("M-\"" . nil)
					 ("C-M-<left>" . nil)
					 ("C-M-<right>" . nil)))
	 #+END_SRC

	 Paredit might not be easy to get used to, but after a while (and a
	 few failed attempts) it becomes natural and one expects it.

**** Goto Source
	 #+BEGIN_SRC emacs-lisp
	   (use-package dumb-jump
		 :after prog-mode
		 :config
		 (setq dumb-jump-aggressive t)
		 :bind (:map prog-mode-map
					 ("M-[" . dumb-jump-go)
					 ("M-]" . dumb-jump-back)))
	 #+END_SRC

	 In addition to projectile, and to avoid using =TAGS= files, =dumb-jump=
	 offers clean and simple say to navigate a project, and find places
	 where variables were declare and used.

**** Error Checking
	 #+BEGIN_SRC emacs-lisp
	   (use-package flycheck
		 :config
		 (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
		 :bind (("C-c <right>" . next-error)
				("C-c <left>" . previous-error)))
	 #+END_SRC

	 Besides installing flycheck, also disable the Elisp warning
	 regarding checkdoc warnings (/first line must be so and so/, /last line
	 must contain this and that/, ...).

**** Auto Completion
	 #+BEGIN_SRC emacs-lisp
	   (use-package company
		 :diminish company-mode
		 :config
		 (setq company-begin-commands '()
			   company-transformers '(company-sort-by-occurrence)
			   company-tooltip-align-annotations t
			   company-tooltip-minimum-width 30
			   company-tooltip-limit 20
			   company-require-match 'never
			   company-selection-wrap-around t)
		 :hook (prog-mode . company-mode)
		 :bind (:map company-mode-map
					 ("M-<tab>" . company-complete)
					 :map company-active-map
					 ("C-n" . company-select-next)
					 ("C-p" . company-select-previous)))
	 #+END_SRC

	 Generally speaking, I have had a better experiance with =company= as
	 compared to =auto-complete-mode=. The

**** Snippets
	 #+BEGIN_SRC emacs-lisp
	   (use-package yasnippet
		 :diminish yas-minor-mode
		 :functions (yas-expand zge/indent-then-expand)
		 :config
		 (setq yas-prompt-functions '(yas-dropdown-prompt yas-completing-prompt)
			   yas-wrap-around-region t)
		 (defun zge/indent-then-expand ()
		   (interactive)
		   (if (and (eq last-command 'indent-then-expand)
					(not (nth 3 (syntax-ppss)))
					(not (nth 4 (syntax-ppss)))
					(looking-at-p (rx (or space eol eos))))
			   (yas-expand)
			 (indent-for-tab-command)))
		 (define-key yas-minor-mode-map (kbd "<tab>") #'zge/indent-then-expand)
		 :hook (prog-mode . yas-minor-mode))
	 #+END_SRC

	 While I have previously had problems with yasnippets, mainly due to
	 snippets expanding when I don't want them to, recent experience has
	 made me long for a snippet system again. The current system, could
	 work: on =<tab>= snippets are only expanded if the last command was
	 =self-insert-command=, i.e. user input. Otherwise, code will be
	 aligned.

	 #+BEGIN_SRC emacs-lisp
	   (use-package yasnippet-snippets :after yasnippet)
	 #+END_SRC

	 Furthermore, make sure a few extra major modes as supported.

*** General Management
**** Ediff
	 #+BEGIN_SRC emacs-lisp
	   (setq ediff-window-setup-function 'ediff-setup-windows-multiframe
			 ediff-split-window-function 'split-window-horizontally)
	 #+END_SRC

	 When using Ediff, don't create a new window.

**** Version Control
	 #+BEGIN_SRC emacs-lisp
	   (use-package magit
		 :if (executable-find "git")
		 :config
		 (setq magit-diff-options "-b --patience"
			   magit-save-repository-buffers 'dontask)
		 :bind ("C-x g" . magit-status))
	 #+END_SRC

	 Magit has been noted to be "a git wrapper that's better than git
	 itself" (most definitely not /sic/), and from my experience, this is
	 true, for the most part. Generally speaking, I do think it has a
	 great user experience, and it uses Emacs potential far better than
	 certain other modes. Another way to compliment it, would be to point
	 out how minimal it's configuration needs to be (at least for me),
	 without being in any sense annoying or otherwise inconvenient.

	 #+BEGIN_SRC emacs-lisp
	   (use-package orgit
		 :after (magit org))
	 #+END_SRC

	 To support linking to git commits, I also install this auxiliary
	 package by the same author as Magit (Jonas Bernoulli). Having that
	 installed I can easily use =C-c l= to create a link, see [[*Org][Org]] for more
	 information.

	 #+BEGIN_SRC emacs-lisp
	   (use-package forge
		 :after magit)
	 #+END_SRC

	 Forge adds support for various "git forges" (ie. websites that
	 allow git to be hosted). Currently I don't see the need for
	 anything to be explicitly configured, so I leave it simple.

**** Project Managment
	 #+BEGIN_SRC emacs-lisp
	   (use-package projectile
		 :diminish
		 :after ivy
		 :commands projectile-mode
		 :init
		 (projectile-mode t)
		 :config
		 (setq projectile-enable-caching t
			   projectile-require-project-root nil
			   projectile-switch-project-action 'projectile-dired
			   projectile-completion-system 'default)
		 :bind ("C-c p" . projectile-command-map))
	 #+END_SRC

	 While I for the most part dislike using global modes, it seems like
	 the project management package /projectile/ works best this way, hence
	 it is set up to work globally.

* Interactive Functions
  All private functions and variables shall be prefixed with =zge/=.

** Toggle dictionary
   #+BEGIN_SRC emacs-lisp
	 (defconst zge/dicts '("german-new8" "british")
	   "list of dictionaries")
	 (defconst zge/input-alist '(("british" . nil)
								 ("german-new8" . "german-postfix")))
	 (defconst zge/toggle-dict-modes '(text-mode rcirc-mode web-mode))
	 (defvar-local zge/dict-ring nil)

	 (defun zge/toggle-dictionary (&optional lang no-check)
	   "Toggle the Ispell dictionary from English to German and vice versa."
	   (interactive (list nil (not current-prefix-arg)))
	   (unless zge/dict-ring
		 (setq zge/dict-ring
			   (let ((ring (make-ring (length zge/dicts))))
				 (mapc (apply-partially #'ring-insert ring) zge/dicts)
				 ring)))
	   (let* ((next-dict (or lang (ring-remove zge/dict-ring)))
			  (next-im (assoc next-dict zge/input-alist)))
		 (ispell-change-dictionary next-dict)
		 (ring-insert zge/dict-ring next-dict)
		 (when (and next-im (eval `(or ,@(mapcar (lambda (m) (fboundp (derived-mode-p m)))
												 zge/toggle-dict-modes))))
		   (set-input-method (cdr next-im))))
	   (unless no-check
		 (flyspell-region (point-min) (point-max))))
   #+END_SRC

   Since I regularly have to switch between English and German, and I am
   a horrible speller, having a quick function to toggle between just
   the two (using [[Spell%20Checking][Spell Checking]]) had been very nice. Additionally, my
   input method is changed based on =zge/input-alist=.

   #+BEGIN_SRC emacs-lisp
	 (defun zge/org-check-lang ()
	   "Look for LANGUAGE tag and turn on the language specified"
	   (save-excursion
		 (goto-char (point-min))
		 (save-match-data
		   (when (re-search-forward (rx bol "#+LANGUAGE: " (group (one-or-more word))) nil t)
			 (let ((lang (pcase (match-string-no-properties 1)
						   ("en" "british")
						   ("de" "german-new8")
						   (other nil))))
			   (when lang
				 (zge/toggle-dictionary lang)
				 (message "Toggled language to \"%s\"" lang)))))))

	 (with-eval-after-load 'org
	   (add-hook 'org-mode-hook #'zge/org-check-lang))
   #+END_SRC

   Most of the time, empirical studies have found, I use
   =zge/toggle-dictionary= in org-mode since half of what I write is in
   English and the other half in German. To make life even easier, this
   function looks for a =#+LANGUAGE= tag (that's usually just used for
   exporting) and turns on that language for this buffer, similarly to
   what =LaTeX-language-de-hook= does.

** Toggle theme
   #+BEGIN_SRC emacs-lisp
	 (defconst zge/light-theme 'tango
	   "constant holding my perfered light theme")

	 (defconst zge/dark-theme 'tango-dark
	   "constant holding my perfered dark theme")

	 (defvar zge/current-theme zge/dark-theme
	   "variable holding my current theme")

	 (defun zge/toggle-theme ()
	   "Toggle the current theme from light to dark and vice versa"
	   (interactive)
	   (disable-theme zge/current-theme)
	   (load-theme (setq zge/current-theme
						 (if (eq zge/current-theme zge/light-theme)
							 zge/dark-theme zge/light-theme)) t))
   #+END_SRC

   Analogously to =toggle-dictionary=, this function is a quick way to
   switch between the two variations of the theme I use (see
   [[Appearance]]).

   #+BEGIN_SRC emacs-lisp
	 (load-theme zge/current-theme)
   #+END_SRC

   Finally, load the current theme, while Emacs is still starting.

** Swap keybindings
   #+BEGIN_SRC emacs-lisp
	 (defun zge/swap-keys (kb1 kb2 &optional map)
	   "Swap the functions behind KB1 and KB2 in MAP"
	   (interactive "kFirst key: \nkSecond key: ")
	   (let* ((m (or map (current-global-map)))
			  (f1 (lookup-key m kb1))
			  (f2 (lookup-key m kb2)))
		 (define-key m kb1 f2)
		 (define-key m kb2 f1)))
   #+END_SRC

   First mentioned [[https://lobste.rs/s/a0uem2/why_neovim_is_better_than_vim_2015#c_gfs3m7][here]], to argue for elisp v.s. vim script, I don't
   need this function that often, nevertheless I keep in here, just in
   case.

   #+BEGIN_SRC emacs-lisp
	 (zge/swap-keys (kbd "C-s") (kbd "C-M-s"))
	 (zge/swap-keys (kbd "C-r") (kbd "C-M-r"))
   #+END_SRC

   As examples, I default isearch to use regular expressions before
   "regular" searching.

** Curl to buffer
   #+BEGIN_SRC emacs-lisp
	 (defun zge/curl (url)
	   "Paste the content behind URL into a new buffer."
	   (interactive "Murl: ")
	   (let* ((bufname (file-name-base url)))
		 (with-current-buffer (generate-new-buffer (if (string-empty-p bufname)
													   "*curl*" bufname))
		   (shell-command (concat "curl --silent " url) (current-buffer))
		   (pop-to-buffer (current-buffer))
		   (set-auto-mode t))))

	 (defalias 'url 'zge/curl)
   #+END_SRC

   Sometimes I just want to easily view some code in emacs (eg. a raw
   github gist), and this functions just makes it easier.

** Replace Region with Hex Charachter References
   #+BEGIN_SRC emacs-lisp
	 (defun zge/xml-hexify (start end)
	   "Convert region into XML hex code"
	   (interactive "rRegion:")
	   (save-excursion
		 (save-restriction
		   (narrow-to-region start end)
		   (goto-char (point-min))
		   (while (not (eobp))
			 (let ((char (following-char)))
			   (delete-char 1)
			   (insert (format "&#x%X;" char)))))))

	 (defalias 'xml-hexify #'zge/xml-hexify)
   #+END_SRC

   When fuzzing Email addresses, replacing ASCII text with Hexadecimal
   [[https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_reference_overview][XML Charachter References]] can make it a bit harder for spiders and
   bots to find and spam you.

   Idea taken from the [[http://www.pell.portland.or.us/~orc/Code/discount/][Discount]] Markdown parser.

** Timestamp
   #+BEGIN_SRC emacs-lisp
	 (defun zge/add-timestamp ()
	   "Prepend a UNIX timestamp to buffer, if it doesn't alreay exits."
	   (interactive)
	   (save-excursion
		 (goto-char (point-min))
		 (insert (format-time-string "%s"))
		 (comment-region (point-min) (point))
		 (end-of-line)
		 (newline 2)))

	 (defalias 'add-timestamp 'zge/add-timestamp)
   #+END_SRC

   For my ad-hoc blog, I insert a UNIX timestamp

** Kill buffer and open Dired
   #+BEGIN_SRC emacs-lisp
	 (with-eval-after-load 'dired-x
	   (defun kill-buffer-and-dired ()
		 "Kill currently opened buffer and replace it with a dired
	 buffer the buffer was in."
		 (interactive)
		 (let ((buf (current-buffer)))
		   (dired-jump)
		   (kill-buffer buf)))

	   (global-set-key (kbd "C-x x j") #'kill-buffer-and-dired))
   #+END_SRC

   The function name says it all. If I want to kill a file, but stay in
   the directory, =kill-buffer-and-dired= is a shortcut for =C-x C-j C-b
   <RET> C-x k <RET>=.

** Recreate =*scratch*= buffer
   #+BEGIN_SRC emacs-lisp
	 (defun new-scratch (&optional keep)
	   "Generate a new *scratch* buffer"
	   (interactive "P")
	   (with-current-buffer (get-buffer-create "*scratch*")
		 (unless keep
		   (save-mark-and-excursion
			 (delete-region (point-min)
							(point-max))))
		 (lisp-interaction-mode)
		 (goto-char (point-min))
		 (insert (substitute-command-keys initial-scratch-message))
		 (set-buffer-modified-p nil))
	   (when (called-interactively-p 'any)
		 (switch-to-buffer "*scratch*")))

	 (add-hook 'after-init-hook #'new-scratch)
   #+END_SRC

   To prevent myself from accidentally killing my =*scratch*= buffer, I
   locally override what the =C-x k= keybinding does, emulating the
   =kill-buffer= function, without actually killing anything.

** Backwards functions
   #+BEGIN_SRC emacs-lisp
	 (defmacro backwardize (func)
	   "Create a interactive function that calls the passed function
	 `func' with a negative argument."
	   `(defun ,(intern (concat (symbol-name func) "-backwards")) (arg)
		  ,(concat "Backwards version of " (symbol-name func))
		  (interactive "p")
		  (,func (- arg))))
   #+END_SRC

   Some functions have backwards complements, others don't. This macro
   makes it easy to create a "backwards" co-function, by negating it's
   argument and appending "-backwards" to the interactive functions'
   name.

   #+BEGIN_SRC emacs-lisp
	 (global-set-key (kbd "M-C") (backwardize capitalize-word))
	 (global-set-key (kbd "M-L") (backwardize downcase-word))
	 (global-set-key (kbd "M-U") (backwardize upcase-word))
   #+END_SRC

   I use =backwardize= to bind backwards-versions of {capitzlize,
   downcase, upcase}-word to =M-S-*=.

   #+BEGIN_SRC emacs-lisp
	 (global-set-key (kbd "M-D") (backwardize kill-word))
   #+END_SRC

   Analogously, allow words to be deleted backwards.

* Global Keybindings
  #+BEGIN_SRC emacs-lisp
	(dolist (bind '(("M-\"" . eshell)
					("<f2>" . window-configuration-to-register)
					("<f5>" . zge/toggle-dictionary)
					("<f6>" . zge/toggle-theme)
					("<f7>" . toggle-truncate-lines)
					("C-c <C-return>" . man)
					("C-x x d" . calendar)
					("C-x M-k" . kill-buffer-and-window)
					("C-x x k" . bury-buffer)
					("C-x j" . jump-to-register)
					("M-#". find-file-at-point)
					("<print>" . other-window)
					("C-M-<up>" . windmove-up)
					("C-M-<down>" . windmove-down)
					("C-M-<left>" . windmove-left)
					("C-M-<right>" . windmove-right)
					("C-M-<backspace>" . delete-region)))
	  (global-set-key (kbd (car bind)) (cdr bind)))
  #+END_SRC

  These are juts a few self-explanatory global, /personal/ keybindings, I
  find useful. All of this is done using the =dolist= macro, to keep
  everything cleaner and easier to read.

  #+BEGIN_SRC emacs-lisp
	(dolist (bind '(("M-l" . downcase-dwim)
					("<backtab>" . completion-at-point)
					("M-c" . capitalize-dwim)
					("<prior>" . scroll-up-command)
					("<next>" . scroll-down-command)
					("<XF86WLAN>" . ignore)
					("M-u" . upcase-dwim)
					("M-SPC" . cycle-spacing)
					("<insert>" . ignore)
					("C-x u" . undo-only)
					("M-/" . hippie-expand)))
	  (global-set-key (kbd (car bind)) (cdr bind)))
  #+END_SRC

  These on the other hand, overrride existing, /default/ keybindings with
  different (eg. =C-z= to repeat), or better (eg. =M-SPC= to cycle-spacing)
  commands.

* Hooks
  Most of the mode specific hooks were already set up in the [[Packages%20and%20Other%20Configurations][Packages
  and Other Configurations]] section, so this part only adds a few more
  general hooks, which apply to more than just one mode.

** Programming
   #+BEGIN_SRC emacs-lisp
	 (define-key prog-mode-map (kbd "C-c w") #'whitespace-mode)
   #+END_SRC

   Easily enable =whitespace-mode= in all programming buffers by using the
   specified keybinding.

   #+BEGIN_SRC emacs-lisp
	 (dolist (map (list prog-mode-map dired-mode-map))
	   (define-key map (kbd "C-c C-k") #'compile))
   #+END_SRC

   Easily start compilation from listed modes.

   #+BEGIN_SRC emacs-lisp
	 (dolist (m '(hs-minor-mode
				  electric-indent-local-mode
				  electric-pair-local-mode
				  flycheck-mode
				  flyspell-prog-mode))
	   (add-hook 'prog-mode-hook m))
   #+END_SRC

   After modifying the programming keymap, make sure a list of minor
   modes are added started in every programming environment.

** Writing
   #+BEGIN_SRC emacs-lisp
	 (add-hook 'text-mode-hook
			   (lambda ()
				 (unless (derived-mode-p 'org-mode)
				   (turn-on-flyspell))))
   #+END_SRC

   The only minor-mode I really use when writing text is flyspell. If I
   do need something else, I turn it on manually.

   #+BEGIN_SRC emacs-lisp
	 (add-hook 'text-mode-hook #'electric-pair-local-mode)
   #+END_SRC

   All text buffers, except for LaTeX-buffers, should automatically
   close opening parentheses.

   #+BEGIN_SRC emacs-lisp
	 (add-hook 'text-mode-hook #'turn-on-auto-fill)
	 (advice-add 'auto-fill-function :after
				 (lambda (&rest _) (scroll-right most-positive-fixnum)))
   #+END_SRC

   When writing text, I usually would keep on pressing =M-q= all the time
   to fill paragraphs, until I found out about =auto-fill-mode= that does
   this automatically as soon as lines become too long. My only issue
   then was that if a window was too narrow (but wider that the fill
   width) Emacs would scroll without scrolling back. To remedy this
   issue, I automatically scroll-right, whenever a paragraph is
   auto-fill'ed (currently a bit buggy).
