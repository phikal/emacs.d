#+TITLE:	A Semi-literate Emacs Configuration
#+OPTIONS:	email:nil H:5
#+KEYWORDS: emacs dotfile config

* Introductory comments
  This document is my configuration for [[https://gnu.org/s/emacs][GNU Emacs]], using [[https://org-mode.org/][Org Mode's]]
  [[https://en.wikipedia.org/wiki/Literate_programming][Literate Programming]] facilities to automatically extract and evaluate
  all the relevant code snippets, ignoring the documenting comments.

  To load this configuration, make sure you have the ~.org~ file locally
  on your system, and call it using ~org-babel-load-file~. Furthermore,
  make sure that you've loaded the ~cl-lib~ module with ~require~.

  This document, it's code and comments, are in the [[https://creativecommons.org/publicdomain/zero/1.0/deed][public domain]].

  The following configuration has been tested on a few different
  systems, with different Emacs versions, but nothing below 25. Ideally
  don't just copy the everything but read and adopt the code snippets
  you think will help /your/ configuration work better for /your/ use case.

  This configuration is more regularly updated [[https://zge.us.to/emacs.d.html][on my website]], and the
  [[https://zge.us.to/git/emacs.d/][Git history]] (+source) is also public (alternatively also to be found
  on [[https://github.com/phikal/emacs.d/][GitHub]]).

  Time of export: {{{time(%c)}}}.

** Personal Emacs History
   My first encounters with Emacs must have been somewhere around late
   2014, when I was looking around to find a proper text
   editor. Overwhelmed by the options, I tried a lot of things out, such
   as Sublime Text or Geany, but all of them felt missing, faulted
   incomplete or simply wrong. It didn't take long for me to understand
   that the two main players turned out to be some of the oldest ones:
   vi (ie. vim) and Emacs (ie. GNU Emacs).

   Knowing nothing, I trusted common opinion and went with Vi(m). And it
   was cool -- a +sin+ penance to say in an Emacs configuration. But while
   the foundations were good, it had problems with being extended,
   personalized, etc. Ultimately, I came to the conclusion that one
   shouldn't customize Vi(m), or at the very least keep it as minimal as
   possible (hence I use =nvi= and =vis= instead of Vim nowadays).

   Yet this conclusion wasn't achieved by itself. It took Emacs to prove
   this, by demonstrating a properly extendable "environment" to teach
   me...

   I remember that there was a bit of a gap between installing and using
   Emacs. For a while I even had issues remembering and recognizing the
   name! A particularly vivid memory is me looking through the Gnome (or
   Unity?) configuration program, and encountering the "input method"
   option, among which "Emacs" was an option -- I assumed it was related
   to Apple's computer brand... But when I opened Emacs for the first
   few times it seemed a bit overwhelming, (unnecessarily) complex and
   unhandy: everything was different. From names over the workflow
   (which I didn't even understand) to the keybindings. All I used to
   do, was open a file (=C-x C-f=), maybe move up and down (=M-v= and =C-v=)
   change the theme (using the menu bar) and then close Emacs (=C-x
   C-x=). That was pretty much all I knew.

   But somewhere around early 2015 (if not earlier) for some reason I
   can't quite remember I was drawn towards Emacs. Possibilities could
   be
   1. Me having have met "real" Emacs users, and drawing my attention to
	  the Editor, making me realize that it's not just a notepad with
	  inconvenient keybindings.
   2. Me having have engaged with Lisp, while to be fair not knowing all
	  it's potential understanding it's beauty.

   So I slowly started trying to configure Emacs. Retroactively it seems
   to me that the resources were far harder to find. Having no idea what
   to do (and lacking the patience to sit through the [[info:Emacs][Emacs Manual]]), I
   copied a few things from some blogs, a few things from some dotfile,
   some stuff from YouTube descriptions and others from Stackoverflow
   questions -- to put it simply, it was a mess, and stuff broke quite
   freqently. I kept on reading that Org mode was great, but I didn't
   ever get why (I did eventually). But for some reason I didn't stop
   using Emacs, but neither did I go too deep.

   After some 2 1/2 years of bare survival, ups and downs, I started to
   find out that people were writing literate configurations.

   Then I read [[https://sites.google.com/site/steveyegge2/tour-de-babel][an article]], that said the following:

   #+BEGIN_QUOTE
   They all used Emacs, of course. Hell, Eric Benson was one of the
   authors of XEmacs1. All of the greatest engineers in the world use
   Emacs. The world-changer types. Not the great gal in the cube next to
   you. Not Fred, the amazing guy down the hall. I'm talking about the
   greatest software developers of our profession, the ones who changed
   the face of the industry. The James Goslings, the Donald Knuths, the
   Paul Grahams2, the Jamie Zawinskis, the Eric Bensons. Real engineers
   use Emacs. [...]

   Emacs is the 100-year editor.
   #+END_QUOTE

   It didn't take long and I decided to rewrite my ~100-150 line
   configuration. My enthusiasm began to blossom somewhere around that
   time. And so, since February 2018 I have been maintaining this file.

** Why use org/babel?
   While it might appear to be a inconvenience at first, extracting ones
   configuration into a format like this one has multiple advantages, of
   which the main ones are:

   - My actual =init.el= is very short. All I do, disable filename
	 handlers, increase the garbage collection threshold, and (if
	 necessary) call Org/Babel. If the extracted file newer than the
	 this org file, I just load that file.
   - Writing text with code (as opposed to code with comments) is much
	 more informative, and makes me justify whatever I add. This, one
	 the one hand contributes to simplicity, but also helps people who
	 are configuring their config get a better feeling for what to do
	 /and/ why.
   - After a while, every novice /should/ entirely rewrite their
	 configuration. In the beginning, one might just copy stuff from
	 Manuals, Wikis and Blogs -- and keep what sicks, but this results
	 in code that's hard to maintain and keep an overview. I pushed
	 myself to rewrite my configuration I started to write around
	 2014-15 and I enjoy a far better experience that had before. My
	 potential had increased and I have used the opportunity to learn
	 more about Emacs itself.

** Inspirations for writing this configuration
   Emacs is a tool you can use for years and always learn something new,
   which make you feel stupid for not having known. The fun part when
   writing a configuration like this one is that one actively learns
   these things, instead of accidentally pressing the wrong keybinding,
   and then going back to =C-h l= to find out what just happened.

   So for my own assistance, and maybe also for other lost souls,
   reading this in the lookout for tricks and wizardry (note: you
   probably won't find any of this in my config), I list here other very
   interesting configurations:

   - [[http://archive.is/qw0r8][Org Mode -- Organize Your Life in Plain Text!]] :: this is not
        strictly a config, but it's an overall great =org-mode=
        overview. Less on the topic of configurations, and more on the
        topic of =org-mode=, [[http://home.fnal.gov/~neilsen/notebook/orgExamples/org-examples.html][Eric H. Neilsen's example page]] is very
        useful to fall back on.
   - [[https://www.freebsd.org/doc/en/books/developers-handbook/emacs.html][Using Emacs as a Development Environment]] :: this offered a few
		c-mode related tricks
   - [[https://www.dgp.toronto.edu/~ghali/emacs.html][Sheruf Ghali's Emacs config]] :: recommendable due to being an
		expansive document with good (although not "literate")
		documentation and commentary.
   - [[https://caolan.org/dotfiles/emacs.html][Caolan McMahon's Emacs Configuration]] :: A lot of packages with
		helpful commentary. Very well structured.
   - [[https://github.com/jwiegley/dot-emacs][John Wiegley's (=use-package= creator) "dot-emacs"]] :: Always up to
		date and permanently changing, this configuration shows a lot of
		maturity.
   - [[https://tuhdo.github.io/emacs-tutor3.html][Tu Do's "Emacs Mini Manual (PART 3)"]] :: Part of a series that
		starts from nothing and gives a great introduction to Emacs. The
		last part (linked here) introduces and explains a lot of useful
		packages, as well as basic elisp concepts (=defun=, =add-to-list=,
		=mapc=, ...)
   - [[https://gitlab.com/j3kyl/dots/blob/master/gnu/.emacs.d/init.el][j3kyl's =init.el=]] :: Very extensive and occasionally obscure
		settings, structured and documented well enough to be
		understandable.
   - [[https://github.com/larstvei/dot-emacs/][Lard Tveito's "dot-emacs"]] :: Another literate configuration that
		demonstrates multiple packages with well written and helpful
		comments.
   - [[https://github.com/hrs/dotfiles/blob/master/emacs/.emacs.d/configuration.org][Harry R. Schwarz' (hrs) "dotfiles"]] :: Part of his overall
		configuration, hrs (Organizer of the NYC Emacs meetup) provides
		an extensive list of packages, tricks and tips.
   - [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's Emacs configuration]] :: /Very/ comprehensive but a bit
		disordered (IMO) literate configuration by the maintainer of the
		(very recommendable) [[http://sachachua.com/blog/category/emacs/][Emacs News]] newsletter.
   - [[https://github.com/codemac/config/blob/master/emacs.d/boot.org][Jeff Mickey's (codemac) Emacs]] :: A bit untidy but extensive/long
		and quite clever literate configuration. Many variables worth
		knowing about, as well as good, thoughtful commentary.
   - [[https://mrblog.nl/emacs/config.html][Marcel van der Boom's "Orgmode configuration"]] :: Impressively long
        configuration with more-than-average commentary and many custom
        functions to extend the default behavior of the many packages
        mentioned. Seems to be written with a German keyboard in mind.
   - [[http://home.thep.lu.se/~karlf/emacs.html][Karl Fogelmark's .emacs]] :: A lot of functions and keybinding-tables
        and otherwise helpful comments, yet written with pre-Emacs 24.1
        in mind so the configuration is a bit verbose.

   All of these configurations are worth reading and re-reading from
   time to time, since one can always find out something new to adopt
   into his/her own configuration.

   A more comprehensive list can be found [[https://github.com/caisah/emacs.dz][here]].

** Short note on my directory structure
   While this configuration aims for a certain degree of portability,
   this isn't universally the case, since it's my personal setup, not a
   cool prelude. Portability is maintained between the devices I use
   Emacs on, by assuming a certain standardized directory structure, as
   follows:

   | Directory                   | Use                                                   |
   |-----------------------------+-------------------------------------------------------|
   | =~/=                          | home                                                  |
   | =~/code/=                     | programming and sysadmin related files                |
   | =~/code/{c,haskell,go,...}=   | directories devoted to specific programming languages |
   | =~/code/etc/...=              | various other projects (including emacs source)       |
   | =~/dl/=                       | downloads gathering directory, preferably empty       |
   | =~/doc/=                      | texts, presentations and notes                        |
   | =~/doc/org/=                  | most org-mode related files                           |
   | =~/media/=                    | general directory for digial media                    |
   | =~/media/{img,vid,music,...}= | specific media directories                            |
   | =~/etc/=                      | various other directories                             |
   | =~/etc/bin/=                  | user binaries                                         |
   | =~/etc/{mail,news,pub}=       | gnus related directories                              |
   | =~/etc/sync=                  | syncthing directory                                   |

   When porting or copying from this configuration, these notes might
   help.

** Software I have installed to aid Emacs
   Emacs makes great use of external software, that's also installed on
   the same system. The following list helps me remember what I have to
   install on a new system, and for what purpose:

   - msmtp :: [[SMTP][Sending Mail]]
   - gpg :: authinfo.gpg de-/encyrption
   - mpd :: [[Multimedia][Multimedia]]
   - curl :: [[Elfeed][RSS/Atom feeds]]
   - ledger :: [[Ledger][Double-entry Accounting]]
   - git :: [[Version%20Controll][Version Controll]] (eg. for this file)
   - aspell :: [[Spell%20Checking][Spell Checking]]
   - ag :: [[Projectile][Project management]]
   - cmark :: [[Markdown]]

   Compilers and interpreters for specific programming enjoyments aren't
   listed here, since I don't necessarily have all of them installed,
   even if they are set up to work in Emacs.

* General Setup
** Lexical Scoping
   #+BEGIN_SRC emacs-lisp
     ;;; -*- lexical-binding: t -*-
   #+END_SRC

   All code written in this file, shall be [[https://stackoverflow.com/questions/1047454/what-is-lexical-scope]["Lexically Scoped"]].

** Package Management
   #+BEGIN_SRC emacs-lisp
     (require 'package)
     (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/"))
     (setq package-enable-at-startup nil
           package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                              ("melpa-stable" . "https://stable.melpa.org/packages/"))
           package-archive-priorities '(("gnu" . 5)
                                        ("melpa-stable" . 10)))

     (package-initialize)
   #+END_SRC

   Only use ~melpa-stabe~ besides the standard gnu repository (which
   should be in ~package-archives~ by default). This makes sure that all
   the packages (see /[[Packages%20and%20Other%20Configurations][Packages]]/).

** Appearance
*** Initially deactivated Modes
	#+BEGIN_SRC emacs-lisp
      (scroll-bar-mode -1)
      (menu-bar-mode -1)
      (tool-bar-mode -1)
      (blink-cursor-mode -1)
      (tooltip-mode -1)
	#+END_SRC

	Since I usually don't need my mouse to use Emacs, I turn off all GUI
	related tools, like scroll- toolbars, etc. This is done early on to
	avoid redrawing during startup.

	As an additional hack, I sometimes place the following in my
	=.Xresources= file, which further improves the startup speed slightly:

	#+BEGIN_EXAMPLE
	emacs.toolBar: 0
	emacs.menuBar: 0
	emacs.verticalScrollBars: off
	#+END_EXAMPLE

*** Fonts
	#+BEGIN_SRC emacs-lisp
      (set-face-font 'default "Input Mono Light-12")
      (set-face-font 'variable-pitch "Lato-12")
	#+END_SRC

	My fonts are configured and changed frequently, making any more
	significant commentary on this code redundant.

*** Parentheses
	#+BEGIN_SRC emacs-lisp
      (setq show-paren-delay 0
            show-paren-when-point-inside-paren t)
      (show-paren-mode t)
	#+END_SRC

	To extend the default Emacs appearance, matching parentheses are
	highlighted, which is helpful when working with Lisp code.

*** Mode-bar customisations
	#+BEGIN_SRC emacs-lisp
      (let ((display-time-24hr-format t))
        (display-time-mode t))
      (display-battery-mode t)
	#+END_SRC

	Furthermore the mode bar displays the current column of the
	active point and the current time, since I usually use Emacs in full
	screen mode withing a window manager without a built in clock
	facility.

*** Startup actions
	#+BEGIN_SRC emacs-lisp
      (setq inhibit-startup-screen t
            inhibit-startup-buffer-menu t
            inhibit-startup-message t
            inhibit-startup-hooks t)
	#+END_SRC

	In accordance to a minimalist and fast startup, I tell Emacs to not
	open the standard startup buffer (with a timestamp of when I opened
	Emacs), since I never use it anyways.

*** Whitespace and Formatting
	#+BEGIN_SRC emacs-lisp
      (setq-default fill-column 72
                    tab-width 4)
	#+END_SRC

	These settings are purely personal preferences.

*** Empty Lines
	#+BEGIN_SRC emacs-lisp
      (defun turn-indicate-empty-lines-on ()
        (setq-local indicate-empty-lines t))

      (add-hook 'prog-mode-hook #'turn-indicate-empty-lines-on)
      (add-hook 'text-mode-hook #'turn-indicate-empty-lines-on)
      (add-hook 'dired-mode-hook #'turn-indicate-empty-lines-on)
	#+END_SRC

	This option makes Emacs populate the left-hand fringe with little
	lines indicating space the frame uses, but the buffer doesn't. This
	only makes sense for buffers I edit manually, like text or programs
	(less so in Eshell and Magit) so I enable it using a hook.

*** Exiting Emacs
	#+BEGIN_SRC emacs-lisp
      (setq confirm-kill-emacs 'yes-or-no-p)
	#+END_SRC

	While it's not quite "appearance"-related, this will prevent Emacs
	from being accidentally closed when I type =C-x C-c= instead of =C-c
	C-x=.

*** Extra-Emacs Clipboard
	#+BEGIN_SRC emacs-lisp
      (setq-default select-enable-clipboard t
                    x-select-enable-clipboard t)
	#+END_SRC

	Having the ability to interact with the system clipboard is very
	welcome, especially when copying code from a (now =eww=) web browser.

*** Frame resizing
	#+BEGIN_SRC emacs-lisp
      (setq frame-resize-pixelwise t)
	#+END_SRC

	When using graphical Emacs, this option enables more flexible
	resizing of the entire frame.

** Cross-session Configuration
   #+BEGIN_SRC emacs-lisp
     (setq history-delete-duplicates t
           savehist-save-minibuffer-history t
           savehist-additional-variables '(kill-ring
                                           search-ring
                                           eshell-history-ring
                                           compile-command
                                           recentf-list
                                           calc-stack)
           savehist-ignored-variables '(tmm--history
                                        yes-or-no-p-history))

     (savehist-mode t)
   #+END_SRC

   The preceding two function calls make sure that in-between opening
   and closing Emacs (for example when I have to shut down my computer)
   buffers and windows are saved, as well as minibuffer inputs plus the
   contents of ~kill-ring~, ~search-ring~ and ~compile-command~. Other
   variables, which are not needed are disregarded.

   #+BEGIN_SRC emacs-lisp
     (setq desktop-restore-frames nil
           desktop-restore-eager 8)

     (desktop-save-mode t)
   #+END_SRC

   To not loose all the buffers between sessions, =desktop-save-mode=
   keeps track of buffers before Emacs exists, /but/ doesn't keep track of
   the frame layout. Furthermore, no buffers are "lazily" restored, but
   instead all at once, since otherwise this leads to an annoying
   behavior where buffers are being restored and Emacs, but because I
   stopped typing for a second.

	#+BEGIN_SRC emacs-lisp
      (save-place-mode t)
	#+END_SRC

	When re-entering a file, return to that place where I was when I
	left it the last time.

** Backups
   #+BEGIN_SRC emacs-lisp
     (setq-default backup-directory-alist
                   `(("" . ,(expand-file-name "backup/" user-emacs-directory)))
                   auto-save-default nil
                   backup-by-copying t
                   version-control t
                   kept-old-versions 3
                   kept-new-versions 8
                   delete-old-versions t)
   #+END_SRC

   The default Emacs backup system is pretty annoying, so these are a
   some helpful tips I've gathered from around the internet, with a few
   modifications based on experience (eg. having have been saved by the
   backup system, more than just a few times).

   *Note:* This is also probably one of the oldest parts on my
   configuration, staying mostly unchanged since mid-late 2014, when
   copied the code from [[https://stackoverflow.com/users/11138/jfm3][this StackOverflow question]].

** Defaults
*** User information
	#+BEGIN_SRC emacs-lisp
      (setq user-full-name "Philip K."
            user-mail-address "philip@warpmail.net")
	#+END_SRC

	Personal data?

*** Unkillable =*scratch*= buffer
	#+BEGIN_SRC emacs-lisp
      (eval-after-load 'lisp-interaction-mode
        (with-current-buffer "*scratch*"
          (lisp-interaction-mode)
          (insert (substitute-command-keys initial-scratch-message))
          (set-buffer-modified-p nil)
          (local-set-key (kbd "C-x k") 'bury-buffer)))
	#+END_SRC

	To prevent myself from accidentally killing my =*scratch*= buffer, I
	locally override what the =C-x k= keybinding does, emulating the
	=kill-buffer= function, without actually killing anything.

*** Minibuffer height
	#+BEGIN_SRC emacs-lisp
      (setq max-mini-window-height 0.40)
	#+END_SRC

	I like executing commands with =M-!=, but I don't like new buffers and
	windows being created. To remedy this, I lessen Emacs general
	sensitivity as to what is "too much" for the Minibuffer from 25% (as
	of writing) to 40% of the window height.

*** Encoding
	#+BEGIN_SRC emacs-lisp
      (prefer-coding-system 'utf-8)
	#+END_SRC

	Assume UTF8 by default.

*** "Large Files"
	#+BEGIN_SRC emacs-lisp
      (setq large-file-warning-threshold 40000000)
	#+END_SRC

	Don't warn me about /larger-but-not-actually-that-large/ files.

*** Prefer newer Bytecode
	#+BEGIN_SRC emacs-lisp
      (setq load-prefer-newer t)
	#+END_SRC

	Quite simple trick to avoid a few bugs that might arise from older
	bytecode being used, even though the elisp file has changed.

*** Disabled functions
	#+BEGIN_SRC emacs-lisp
      (setq disabled-command-function nil)
	#+END_SRC

	By default Emacs disables some commands that have to be manually
	enabled by the user, when the keybinding is used or the function is
	called. This snippet ([[https://www.emacswiki.org/emacs/DisabledCommands][source]]) disables this by default, thus
	enabling all commands.

*** Uniquify
	#+BEGIN_SRC emacs-lisp
      (setq uniquify-buffer-name-style 'forward
            uniquify-after-kill-buffer-p t
            uniquify-ignore-buffers-re "^\\*")
	#+END_SRC

	It happens far too often that I open two files with the same name,
	eg. two =Makefile= or =.gitignore= files. To make this "mistake" more
	pleasant, I customize the default behavior.

*** Aliases
	#+BEGIN_SRC emacs-lisp
      (defalias 'yes-or-no-p 'y-or-n-p)
      (defalias 'perl-mode 'cperl-mode)
      (defalias 'ff 'find-file)
      (defalias 'ffo 'find-file-other-window)
	#+END_SRC

	Don't use =perl-mode=, but =cperl-mode=! And instead of having to type
	"yes" or "no" when emacs asks a question, respectively accept "y" or
	"n" instead.

*** Emacs-generated files
	#+BEGIN_SRC emacs-lisp
      (let ((custom-el (expand-file-name "custom.el" user-emacs-directory)))
        (setq-default custom-file custom-el)
        (when (file-exists-p custom-el)
          (load custom-file)))
	#+END_SRC

	I previously attempted to set =custom-file= to =/dev/null/=, but sadly I
	kept getting the message that the find could not be
	found. Therefore, to not clutter =init.el=, I dump all the
	configurations in =~/.emacs.d/custom.el=.

*** Sentences
	#+BEGIN_SRC emacs-lisp
      (setq-default sentence-end "[.!?][\W_]*[[:space:]]+")
	#+END_SRC

	I dislike the standard sentence definition Emacs uses, since for me
	a sentence is just a publication mark, followed by white space.
	Optionally, non-word characters are acceptable between the
	punctuation and the whitespace, like when writing =_No!_= in Markdown.

*** Emacs C source
	#+BEGIN_SRC emacs-lisp
      (let ((c-source (expand-file-name "~/code/etc/emacs/src")))
        (when (file-directory-p c-source)
          (setq find-function-C-source-directory c-source)))
	#+END_SRC

	In case I have the Emacs C-source locally installed, I inform my
	current session about it, in case I want to inspect some low level
	code.

*** Mark Ring
	#+BEGIN_SRC emacs-lisp
      (setq set-mark-command-repeat-pop t
            mark-ring-max 32)
	#+END_SRC

	From the manual:

	#+BEGIN_QUOTE
	 If you set set-mark-command-repeat-pop to non-nil, then immediately
	 after you type C-u C-<SPC>, you can type C-<SPC> instead of C-u
	 C-<SPC> to cycle through the mark ring.
	#+END_QUOTE

	and

	#+BEGIN_QUOTE
	 The variable mark-ring-max specifies the maximum number of entries
	 to keep in the mark ring. This defaults to 16 entries. If that many
	 entries exist and another one is pushed, the earliest one in the
	 list is discarded.
	#+END_QUOTE

*** Recent files
	#+BEGIN_SRC emacs-lisp
      (recentf-mode t)
	#+END_SRC

	For tools like [[projectile-mode][Projectile]], recentf is enabled, so to easily access
	recently opened files.

*** Setting the right mode
	#+BEGIN_SRC emacs-lisp
      (setq-default major-mode (lambda ()
                                 (unless buffer-file-name
                                   (let ((buffer-file-name (buffer-name)))
                                     (set-auto-mode)))))
	#+END_SRC

	When creating new buffers, use =auto-mode-alist= to automatically set
	the major mode. Snippet from [[https://emacs.stackexchange.com/a/2555][Stackoverflow]].

*** Time Locale
	#+BEGIN_SRC emacs-lisp
      (setq system-time-locale "C")
	#+END_SRC

	Force Emacs (especially =org-mode=) to use English timestamps.

*** Abbrevations
	#+BEGIN_SRC emacs-lisp
      (setq abbrev-file-name (expand-file-name "abbrev.defs" user-emacs-directory)
            save-abbrevs 'silent)
	#+END_SRC

	This setup will automatically initialize and save new abbreviations,
	which are used for [[Writing][writing]].

*** Shell comands
	#+BEGIN_SRC emacs-lisp
      (setq-default async-shell-command-display-buffer nil
                    async-shell-command-buffer 'new-buffer)
	#+END_SRC

	When asynchronously running commands, only create a /new/ output
	buffer, if one is needed.

*** Calendar
	#+BEGIN_SRC emacs-lisp
      (setq-default calendar-week-start-day 1
                    calendar-longitude 10.9887
                    calendar-latitude 49.4771
                    calendar-date-style 'iso
                    calendar-christian-all-holidays-flag t
                    calendar-mark-holidays-flag t
                    calendar-mark-diary-entries-flag t)
	#+END_SRC

	The default Emacs calendar configuration is a bit simplistic and
	peculiar. I've always been used to weeks starting on Monday and
	prefer ISO over the American date format, so I set calendar to work
	accordingly. Furthermore, I request holidays and diary entries to be
	highlighted.

	#+BEGIN_SRC emacs-lisp
      (add-hook 'calendar-move-hook
                (lambda ()
                  (when (calendar-check-holidays (calendar-cursor-to-date t nil))
                    (calendar-cursor-holidays))))
	#+END_SRC

	This hook prints the holiday under the cursor to the minibuffer, in
	there there is any, since this seemingly cannot be enabled by
	default.

	#+BEGIN_SRC emacs-lisp
      (setq holiday-general-holidays
            '((holiday-fixed 1 1 "New Year")
              (holiday-fixed 5 1 "1st Mai")
              (holiday-fixed 10 3 "Tag der Deutschen Einheit")
              (holiday-fixed 12 31 "Sylvester")))

      (setq holiday-christian-holidays
            '((holiday-fixed 1 6 "Heilige Drei Könige")
              (holiday-easter-etc -48 "Rosenmontag")
              (holiday-easter-etc  -2 "Karfreitag")
              (holiday-easter-etc   0 "Ostersonntag")
              (holiday-easter-etc  +1 "Ostermontag")
              (holiday-easter-etc +39 "Christi Himmelfahrt")
              (holiday-easter-etc +49 "Pfingstsonntag")
              (holiday-easter-etc +50 "Pfingstmontag")
              (holiday-easter-etc +60 "Fronleichnam")
              (holiday-fixed 8 15 "Mariae Himmelfahrt")
              (holiday-fixed 11 1 "Allerheiligen")
              (holiday-float 11 0 1 "Totensonntag" 20)
              (holiday-float 12 0 -4 "1. Advent" 24)
              (holiday-float 12 0 -3 "2. Advent" 24)
              (holiday-float 12 0 -2 "3. Advent" 24)
              (holiday-float 12 0 -1 "4. Advent" 24)
              (holiday-fixed 12 25 "1. Weihnachtstag")
              (holiday-fixed 12 26 "2. Weihnachtstag")))
	#+END_SRC

	Based on the [[https://www.emacswiki.org/emacs/CalendarLocalization#toc32][EmacsWiki /Calendar Localization/ Article]], I list inform
	Emacs German/Bavarian holidays, since these are relevant to me.

*** Writing while region is active
	#+BEGIN_SRC emacs-lisp
      (delete-selection-mode -1)
	#+END_SRC

	When I've selected a region, and I type something, the region is
	supposed to be deleted automatically.

** Registers
   #+BEGIN_SRC emacs-lisp
     (dolist (c `((?h . "~")
                  (?d . "~/dl/")
                  (?\; . "~/code")
                  (?w . "~/code/web/www/")
                  (?W . "~/code/web/")
                  (?s . "~/code/web/start.md")
                  (?c . ,(expand-file-name "conf.org" user-emacs-directory))
                  (?C . ,(expand-file-name "custom.el" user-emacs-directory))
                  (?D . ,(expand-file-name "diary" user-emacs-directory))
                  (?o . "~/doc/org/")
                  (?n . "~/doc/org/notes.org")
                  (?p . "~/doc/org/pers.org")
                  (?j . "~/doc/org/ws18.org")
                  (?r . "~/doc/read/")
                  (?u . "~/doc/uni/")
                  (?l . ,(format-time-string "~/doc/ledger/%Y/%m.lg"))))
       (set-register (car c) (cons 'file (expand-file-name (cdr c)))))
   #+END_SRC

   To quickly access certain files I tend to frequently use, I use
   Emacs's [[info:emacs#File%20Registers][file registers]].

** Hacks
   #+BEGIN_SRC emacs-lisp
     (add-hook 'emacs-startup-hook
               (lambda ()
                 (with-current-buffer "*scratch*"
                   (lisp-interaction-mode t))))
   #+END_SRC

   I /reload/ =lisp-interaction-mode= to make sure that all the =prog-mode=
   hooks and modifiers get applied to the =*scratch*= buffer.

* Packages and Other Configurations
  #+BEGIN_SRC emacs-lisp
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package t))
    ;; (require 'bind-key)
    (setq-default use-package-always-defer t
                  use-package-always-ensure t)
  #+END_SRC

  Generally, always defer packages and ensure their installation, unless
  otherwise specified. It is assumed that =use-package= has already been
  installed.

** Utilities
*** Text Manipulation
**** Dynamic Expansion
	 #+BEGIN_SRC emacs-lisp
       (setq hippie-expand-try-functions-list
             '(try-expand-dabbrev-visible
               try-expand-dabbrev
               try-expand-dabbrev-from-kill
               try-expand-dabbrev-all-buffers
               try-complete-file-name-partially
               try-complete-file-name
               try-expand-all-abbrevs))
	 #+END_SRC

	 For some reason =hippie-expand= (and it's little sister =dabbrev=) was
	 one of the tools I never noticed but couldn't forget about when I
	 did. Expanding dynamically and even quite intelligently, in all
	 buffers is something one might not quite understand at first, or
	 even find confusing, but especially in the context of Emacs is
	 really cool. To aid this experience, I've set and ordered a few
	 extra expand functions, I find helpful.

**** Expand Region
	 #+BEGIN_SRC emacs-lisp
       (use-package expand-region
         :bind ("C-=" . er/expand-region))
	 #+END_SRC

	 The =expand-region= utility is a helpful function that let's the user
	 select increasingly larger semantically meaningful regions. I've
	 bound it to the recommended default

**** Jump in Buffer
	 #+BEGIN_SRC emacs-lisp
       (use-package avy
         :config
         (avy-setup-default)
         :bind (("C-z" . avy-goto-char)))
	 #+END_SRC

	 When editing text, most time isn't (or shouldn't be) spent on
	 manipulating text /per se/.

*** Extensions
**** Auto-completion
	 #+BEGIN_SRC emacs-lisp
       (use-package ivy
         :diminish (ivy-mode counsel-mode)
         :init
         (setq ivy-wrap t
               ivy-height 6
               ivy-display-style 'fancy
               ivy-case-fold-search-default t
               ivy-re-builders-alist '((t . ivy--regex))
               counsel-find-file-at-point t
               enable-recursive-minibuffers t)
         :config
         (ivy-mode t)
         (counsel-mode t)
         (dolist (cmd '(yank-pop describe-bindings))
           (define-key counsel-mode-map `[remap ,cmd] nil))
         :bind (("M-`" . ivy-resume)
                ("C-x C-r" . counsel-recentf)
                ("C-c s" . counsel-ag)
                ("C-c C-/" . swiper)
                ("C-c f" . counsel-locate)
                :map ivy-minibuffer-map
                ("<RET>" . ivy-alt-done)))
	 #+END_SRC

	 I use Ivy to extend the default =find-file=, =switch-to-buffer=,
	 etc. commands. Compared to it's alternatives, Ivy is simpler that
	 Helm but more powerful (and faster) than Ido. Counsel extends this
	 to further integrate Ivy features into default commands, such as =M-x=,
	 =C-x b= or =C-x C-f=.

	 #+BEGIN_SRC emacs-lisp
       (use-package flx
         :config
         (add-to-list 'ivy-re-builders-alist '(counsel-M-x . ivy--regex-fuzzy))
         :after ivy)
	 #+END_SRC

**** Buffer overview
	 #+BEGIN_SRC emacs-lisp
       (setq ibuffer-expert t)
	 #+END_SRC

	 Ibuffer has turned out to be quite a nifty alternative to
	 =list-buffers=. Not only does it support filter-groups, as presented
	 here, but buffers can be filtered by modes, content or miscellaneous
	 attributes. This presents itself as very helpful, when managing a
	 large amount (more than 100) of buffer.

**** Window Management
	 #+BEGIN_SRC emacs-lisp
       (use-package winner
         :demand
         :init
         (setq winner-dont-bind-my-keys t)
         :config
         (winner-mode)
         :bind (("C-x <down>" . winner-undo)
                ("C-x <up>" . winner-redo)))
	 #+END_SRC

	 The =winner-mode= global mode lets it's user easily recreate previous
	 window configurations, similarly to regular undo'ing in buffers. I
	 don't use the default =C-c <right>= and =C-c <left>= configuration,
	 since this conflicts with my muscle memory for flycheck's
	 next/previous error, so I use rebound the keys.

*** OS Management and Tools
**** Directory Managment
	 #+BEGIN_SRC emacs-lisp
       (require 'dired)
       (require 'dired-x)

       (setq-default dired-dwim-target t
                     dired-recursive-copies 'always
                     dired-recursive-deletes 'top
                     dired-ls-F-marks-symlinks t
                     dired-ls-sorting-switches "v"
                     dired-omit-files-p nil
                     dired-listing-switches "-NABhl --group-directories-first")
       (add-to-list 'dired-guess-shell-alist-user '("\\.pdf\\'" "mupdf"))

	 #+END_SRC

	 Not much to say: For the most part, a under-customized dired
	 configuration.

	 #+BEGIN_SRC emacs-lisp
       (setq-default wdired-allow-to-change-permissions t
                     wdired-allow-to-redirect-links t)
	 #+END_SRC

	 Wdired by default only allows one to edit file names. Setting these
	 variables, extends the abilities of this very interesting minor
	 mode.

**** Integrated Shell
	 #+BEGIN_SRC emacs-lisp
       (setq-default eshell-banner-message "")
	 #+END_SRC

	 Eshell works quite well out of the box, all I want is to turn off
	 the banner.

**** Terminal Emulation
	 #+BEGIN_SRC emacs-lisp
       (setq explicit-shell-file-name (executable-find "sh"))
	 #+END_SRC

	 Use =sh= instead of =bash= as the =term= subshell.

	 #+BEGIN_SRC emacs-lisp
       (advice-add 'term-handle-exit :after
                   (lambda (&rest args)
                     (kill-buffer (current-buffer))))
	 #+END_SRC

	 Don't keep the buffer around as soon as the process ends.

*** Networking
**** Mail
***** Gnus
	  #+BEGIN_SRC emacs-lisp
        (use-package gnus
          :config
      #+END_SRC

	  The following configuration is wrapped in a =use-package= macro...

	  #+BEGIN_SRC emacs-lisp
        (setq message-directory "~/etc/mail/"
              gnus-directory "~/etc/news/")
	  #+END_SRC

	  Before anything happens, I specify my directories in accordance
	  to [[*Short%20note%20on%20my%20directory%20structure]["Short note on my directory structure"]].

	  #+BEGIN_SRC emacs-lisp
        (setq gnus-use-full-window nil
              gnus-novice-user nil
              gnus-expert-user t)
	  #+END_SRC

	  =gnus-use-full-window= prevents Gnus from disturbing my current
	  window setup, and instead tries to just use the current window.

	  The last two options make sure that Gnus doesn't have to prompt me
	  all the time. Note that their names doesn't reflect the actual
	  abilities of the user.

	  #+BEGIN_SRC emacs-lisp
        (setq gnus-select-method '(nnnil ""))
	  #+END_SRC

	  My setup requires two addresses to be set up:
	  1. my personal email hosted by [[https://fastmail.com][Fastmail]]
	  2. My university email hosted by... my University?

	  For that reason I don't specify a "main" address, but instead
	  precede to describe where Gnus should fetch it's mail from...

	  #+BEGIN_SRC emacs-lisp
        (setq gnus-posting-styles nil)

        (add-to-list 'gnus-secondary-select-methods
                     '(nnimap "imap.fastmail.com"
                              (nnimap-split-methods default)
                              (nnimap-expunge t)
                              (nnimap-stream ssl)
                              (nnimap-streaming t)
                              (nnir-search-engine imap)))
        (add-to-list 'gnus-posting-styles
                     '("imap.fastmail.com"
                       (signature "Sincerely\nPhilip K.")
                       (address "philip@warpmail.net")))
	  #+END_SRC

	  ... starting with my personal address ...

	  #+BEGIN_SRC emacs-lisp
        (add-to-list 'gnus-secondary-select-methods
                     '(nnimap "faumail.fau.de"
                              (nnimap-split-methods default)
                              (nnimap-expunge t)
                              (nnimap-stream ssl)
                              (nnimap-streaming t)
                              (nnir-search-engine imap)))
        (add-to-list 'gnus-posting-styles
                     '("faumail.fau.de"
                       (signature "Hochachtungsvoll\nPhilip K.")
                       (address "philip.kaludercic@fau.de")))
	  #+END_SRC

	  ... and then with my university address.

	  Both use IMAP and have a language specific signature.

      #+BEGIN_SRC emacs-lisp
        (setq gnus-summary-line-format "%U%R │ %d% │ %4k: %4{%-23,23F%} │%(%B%S%)\n"
              gnus-sum-thread-tree-single-indent   (propertize "   " 'family "Monospace")
              gnus-sum-thread-tree-false-root      (propertize "   " 'family "Monospace")
              gnus-sum-thread-tree-root            (propertize "┌  " 'family "Monospace")
              gnus-sum-thread-tree-vertical        (propertize "│  " 'family "Monospace")
              gnus-sum-thread-tree-leaf-with-other (propertize "├→ " 'family "Monospace")
              gnus-sum-thread-tree-single-leaf     (propertize "└→ " 'family "Monospace")
              gnus-sum-thread-tree-indent          (propertize "   " 'family "Monospace")

              gnus-group-line-format "%M%p%5y%2[:%] %(%G%)\t%m\n")
        (add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
	  #+END_SRC

	  To make the default summaries a bit easier to parse and read, I
	  have changed the default column formatting and made
	  tree-formatting look better using some Unicode.

	  The group buffer line format has also been changed, to discard
	  information I don't need, since /topic mode/ is turned on.

	  #+BEGIN_SRC emacs-lisp
        (setq gnus-thread-sort-functions '(gnus-thread-sort-by-number))
	  #+END_SRC

	  Generally, I don't use Gnus' scoring system. Everything I care
	  about is the temporal order in which I received messages,
	  ie. their "number".

	  #+BEGIN_SRC emacs-lisp
        (setq gnus-treat-from-gravatar 'head
              gnus-treat-mail-gravatar 'head)
	  #+END_SRC

	  For no other reason than personal preference, I enable [[https://en.wikipedia.org/wiki/Gravatar][Gravatar]].

	  #+BEGIN_SRC emacs-lisp
        (setq mm-discouraged-alternatives '("text/html" "text/richtext"))
	  #+END_SRC

	  There is no reason to prefer HTML mail (at least for me), since it
	  just makes it harder and more complicated to display properly and
	  good readability. Hence I'll try to avoid these, if possible.

	  #+BEGIN_SRC emacs-lisp
        (setq mm-inline-large-images t)
	  #+END_SRC

	  By default Gnus wants to use external tools to open "larger"
	  images, when they're attached to a mail. Since I don't need this,
	  I force inline opening in all cases.

	  #+BEGIN_SRC emacs-lisp
        (setq gnus-agent t
              gnus-agent-consider-all-articles t
              gnus-agent-prompt-send-queue t)
        (add-hook 'gnus-select-article-hook 'gnus-agent-fetch-selected-article)
	  #+END_SRC

	  The [[info:gnus#Agent%20Basics][Agent System]] allows Gnus to cache and then read messages when
	  I don't have a active connection to my server.

      #+BEGIN_SRC emacs-lisp
        (setq mm-verify-option 'always
              mm-decrypt-option 'always
              mm-sign-option 'guided
              mm-encrypt-option 'guided
              gnus-message-replyencrypt t
              gnus-message-replysign t
              gnus-message-replysignencrypted t
              gnus-treat-x-pgp-sig t
              mml2015-sign-with-sender t)
	  #+END_SRC

	  Setup Gnus' encryption, signing and verification system.

	  #+BEGIN_SRC emacs-lisp
        (setq epa-pinentry-mode 'loopback)
	  #+END_SRC

	  Since my =.authsource= is encrypted, I have to enter my password from
	  time to time to access my mail. This also requires
	  =~/.gnupg/.gpg-agent.conf= to contain the following two lines,

	  #+BEGIN_EXAMPLE
	  allow-emacs-pinentry
	  allow-loopback-pinentry
	  #+END_EXAMPLE

	  so that "pintetry" is used for query my paraphrase.

	  #+BEGIN_SRC emacs-lisp
        (gnus-demon-add-scanmail)
        (gnus-demon-scan-mail)
	  #+END_SRC

	  Start demons to improve overall experience.

	  #+BEGIN_SRC emacs-lisp
        :bind (("C-x x m" . gnus)
               ("C-x x M" . gnus-unplugged)))
	  #+END_SRC

	  Finally keybindings are set up.

***** SMTP
	  #+BEGIN_SRC emacs-lisp
        (setq message-send-mail-function 'message-send-mail-with-sendmail
              message-sendmail-extra-arguments '("--read-envelope-from")
              message-sendmail-f-is-evil t
              message-sendmail-envelope-from 'header
              message-kill-buffer-on-exit t
              sendmail-program (executable-find "msmtp"))
	  #+END_SRC

	  Instead of using Emacs' internal SMTP service, I use msmtp, simply
	  for the sake of speed. Additionally, this setup automatically
	  chooses what server to contact, based on the =From:= field.

	  #+BEGIN_SRC emacs-lisp
        (add-hook 'message-mode-hook 'turn-on-orgstruct++)
        (add-hook 'message-mode-hook 'turn-on-orgtbl)
	  #+END_SRC

	  Furthermore, =orgstruct= is enabled to help writing and structuring
	  emails similarly to =org-mode= buffers.

***** BBDB
	  #+BEGIN_SRC emacs-lisp
        (use-package bbdb
          :init
          (setq bbdb-mua-auto-update-p nil
                bbdb-complete-mail-allow-cycling t
                bbdb-use-pop-up nil
                bbdb-completion-display-record nil
                bbdb-file (expand-file-name "bbdb" user-emacs-directory)
                compose-mail-user-agent-warnings nil)
          :config
          (bbdb-initialize 'gnus 'message 'pgp)
          (with-eval-after-load 'message-mode
            (define-key message-mode-map (kbd "M-<tab>") 'bbdb-complete-mail))
          :after gnus)
	  #+END_SRC

	  Install and setup /BBDB/ (Insidious Big Brother Database) for contact
	  management, and enable completion in message buffers.

**** IRC
	 #+BEGIN_SRC emacs-lisp
       (use-package erc
         :demand t
         :init
         (setq erc-rename-buffers t
               erc-join-buffer 'bury           ; because of ZNC
               erc-max-buffer-size 40000
               erc-track-enable-keybindings t
               erc-track-exclude-server-buffer t
               erc-track-remove-disconnected-buffers t
               erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
                                         "324" "329" "332" "333" "353" "477")
               erc-track-shorten-aggressively t
               erc-server-reconnect-attempts 10
               erc-server-reconnect-timeout 1
               erc-server-auto-reconnect t
               erc-button-url-regexp "\\([-a-zA-Z0-9_=!?#$@~`%&*+\\/:;,]+\\.\\)+[-a-zA-Z0-9_=!?#$@~`%&*+\\/:;,]*[-a-zA-Z0-9\\/]"
               erc-spelling-dictionaries '(("zge.us.to" . "de"))
               erc-prompt (lambda () (concat (buffer-name) ">")))
         :config
         (add-to-list 'erc-modules 'spelling)
         (erc-tls :server "zge.us.to"
                  :port 23551
                  :nick "zge"
                  :password (concat "zge/ircnet:" zge/znc-pass))
         :bind (("C-x x x" . erc-track-switch-buffer)
                :map erc-mode-map
                ("C-x k" . bury-buffer)))
	 #+END_SRC

	 For IRC, I use ERC The =zge/znc-pass= variables is declared in my
	 [[*Emacs-generated%20files][custom.el]] file. On starting my Emacs session, rcirc automatically
	 connects

**** Feed Syndication
	 #+BEGIN_SRC emacs-lisp
       (use-package elfeed
         :config
         (setq elfeed-search-filter "@1-month-ago +unread")
         (run-at-time nil (* 60 60) #'elfeed-update)
         :bind ("C-x x f" . elfeed))
	 #+END_SRC

	 My newsreader is even in Emacs! What a supp rise. Elfeed almost
	 certainly the most popular package for this task, and I can highly
	 recommend it, especially if ones gets a bit bored in between doing
	 "work".

	 My =elfeed-feeds= variable isn't specified here, but it's kept in my
	 =custom.el= file.

**** Browser
	 #+BEGIN_SRC emacs-lisp

       (setq-default browse-url-browser-function 'browse-url-firefox
                     eww-download-directory (expand-file-name "~/dl")
                     eww-search-prefix "https://duckduckgo.com/lite/?q="
                     shr-color-visible-luminance-min 15
                     shr-color-visible-distance-min 5)
	 #+END_SRC

	 Use whatever is set as the default browser on the current system,
	 when opening =http://= links. (But still let =eww= be properly
	 configured.) Additionally, the contrast is increased to make
	 webpages (and HTML emails) with peculiar background colors render
	 better.

**** Translation
	 #+BEGIN_SRC emacs-lisp
       (use-package google-translate
         :init
         (setq google-translate-show-phonetic t
               google-translate-enable-ido-completion t
               google-translate-default-source-language "en"
               google-translate-default-target-language "de")
         :bind (("C-c t t" . google-translate-at-point)
                ("C-c t T" . google-translate-at-point-reverse)
                ("C-c t q" . google-translate-query-translate)
                ("C-c t Q" . google-translate-query-translate-reverse)))
	 #+END_SRC

	 When translating or writing texts, this package shows itself to be
	 quite helpful, when I can't thing of a word.

*** General Tools and Programs
**** Spell Checking
	 #+BEGIN_SRC emacs-lisp
       (setq-default ispell-program-name (executable-find "aspell")
                     ispell-extra-args '("--sug-mode=normal" "--keyboard=standard")
                     flyspell-issue-welcome-flag nil
                     flyspell-issue-message-flag nil)
	 #+END_SRC

	 When just writing prose, or just comments, =flyspell-mode= (and
	 =flyspell-prog-mode=) prove themselves to be valuable utilities,
	 albeit a bit slow and cumbersome from time to time...

**** RPN Calculator
	 #+BEGIN_SRC emacs-lisp
       (setq-default calc-angle-mode 'rad
                     calc-shift-prefix t
                     calc-infinite-mode t
                     calc-vector-brackets nil
                     calc-vector-commas nil
                     calc-matrix-just 'right
                     calc-matrix-brackets '(R O)
                     calc-complex-format 'i)
	 #+END_SRC

	 I have grown fond of Emacs Calc, even though it might is be big
	 complicated to go beyond the basics. Most of these options have been
	 taken from the auto generated =calc.el= file.

**** Accounting
	 #+BEGIN_SRC emacs-lisp
       (use-package ledger-mode
         :init
         (setq ledger-source-directory (expand-file-name "~/doc/ledger")
               ledger-reconcile-default-commodity "EUR"
               ledger-clear-whole-transactions t
               ledger-master-file (expand-file-name "master.lg" ledger-source-directory)
               ledger-report-use-native-highlighting  t
               ledger-use-iso-dates t
               ledger-post-auto-adjust-amounts t)
         :config
         (add-hook 'ledger-mode-hook
                   (lambda ()
                     (add-hook 'before-save-hook
                               (lambda ()
                                 (save-excursion (ledger-mode-clean-buffer)))
                               t t)))
         :mode ("\\.lg\\'" . ledger-mode))
	 #+END_SRC

	 In an effort to use ledger, I have set up =ledger-mode= with some
	 sane defaults.

**** PDF Viewer
	 #+BEGIN_SRC emacs-lisp
       (use-package pdf-tools
         :config
         (pdf-tools-install)
         (setq pdf-view-display-size 'fit-page)
         :mode ("\\.pdf\\'" . pdf-view-mode))
	 #+END_SRC

	 Adding PDF-Tools let's me use emacs properly for opening PDFs,
	 making me less dependant on external tools and window managers.

*** Fun
**** Go/Baduk
	 #+BEGIN_SRC emacs-lisp
       (use-package gnugo)
	 #+END_SRC

	 Play Go in Emacs.

** Programming
*** Text Editing
**** LaTeX/AUCTeX
	 #+BEGIN_SRC emacs-lisp
       (use-package auctex
         :config
         (progn
           (add-hook 'LaTeX-mode-hook
                     (lambda ()
                       (setq-local company-backends '(company-latex-commands
                                                      company-math))
                       (flycheck-mode t)
                       (turn-on-reftex)
                       (TeX-fold-mode)))
           (add-hook 'LaTeX-language-de-hook
                     (lambda () (ispell-change-dictionary "de_DE")))
           (add-hook 'TeX-after-compilation-finished-functions
                     'TeX-revert-document-buffer))
         :init
         (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
               TeX-source-correlate-start-server t
               LaTeX-electric-left-right-brace t
               TeX-auto-save t
               TeX-parse-self t
               TeX-master nil
               TeX-PDF-mode t
               reftex-plug-into-AUCTeX t
               reftex-enable-partial-scans t)
         :mode ("\\.tex\\'" . LaTeX-mode))
	 #+END_SRC

	 Partially rewritten LaTeX configuration.

	 #+BEGIN_SRC emacs-lisp
       (use-package cdlatex
         :after auctex
         :init
         (add-hook 'LaTeX-mode-hook 'cdlatex-mode)
         :config
         (add-to-list 'cdlatex-math-modify-alist
                      '(?B "\\mathbb" nil t nil nil)))
	 #+END_SRC

	 Additionally, CDLaTeX provides a more comfortable input and
	 intuitive automation, where possible.

	 #+BEGIN_SRC emacs-lisp
       (use-package company-math
         :after company)
	 #+END_SRC

	 To properly use company mode with math-autocompletion, this package
	 has to be installed.

**** Org
	 #+BEGIN_SRC emacs-lisp
       (use-package org
         :demand t
         :init
	 #+END_SRC

	 The following configuration is wrapped in a =use-package= macro...

	 #+BEGIN_SRC emacs-lisp
       (setq org-use-speed-commands t
             org-hide-emphasis-markers t
             org-yank-adjusted-subtrees t
             org-startup-folded t
             org-highlight-latex-and-related '(latex entities)
             org-M-RET-may-split-line '((default))
             org-special-ctrl-a/e t
             org-special-ctrl-k t)
	 #+END_SRC

	 Basic stylistic and movment options (especially enabling using the
	 shift key to mark a region).

	 #+BEGIN_SRC emacs-lisp
       (setq org-fontify-whole-heading-line t
             org-fontify-quote-and-verse-blocks nil
             org-src-fontify-natively t
             org-src-tab-acts-natively t
             org-src-window-setup 'current-window)
	 #+END_SRC

	 Especially this document uses a lot of source blocks, so
	 highlighting and indenting them appropriately is very convenient.

	 #+BEGIN_SRC emacs-lisp
       (setq org-directory (expand-file-name "~/doc/org/")
             org-agenda-files (list org-directory)
             org-agenda-include-diary t
             org-agenda-window-setup 'current-window
             org-default-notes-file (expand-file-name "notes.org" org-directory))
	 #+END_SRC

	 Within my documents directory (=~/doc/=) I have an =org= directory just
	 for org files, which I notify =org-mode= of. Furthermore, I inform Org
	 about my notes and agenda file.

	  #+BEGIN_SRC emacs-lisp
        (setq org-capture-templates
              '(("a" "Appointment" entry (file+headline "pers.org" "Appointments")
                 "* %^t %?\n")
                ("t" "Todo" entry (file+headline "pers.org" "Todo")
                 "* TODO %?\n  %T\n\n  %i")
                ("c" "Note" entry (file+datetree org-default-notes-file)
                 "* %?\n  Entered on %U")
                ("l" "Link" entry (file+datatree org-default-notes-file)
                 "* %?\n\ %a\n  Entered on %U")))
	  #+END_SRC

	  Having special /capture templates/ will probably help in getting used
	  to using org-mode for taking notes.

	  #+BEGIN_SRC emacs-lisp
        (setq org-todo-keywords '((sequence "TODO(t)" "WAIT(w)" "NEXT(n)" "DONE(d)")))
	  #+END_SRC

	  Since I don't require a complex TODO setup, I have chosen to keep
	  the default keywords, as one often finds them recommended.

	  #+BEGIN_SRC emacs-lisp
        (setq org-export-date-timestamp-format "%X"
              org-html-metadata-timestamp-format "%X"
              org-export-dispatch-use-expert-ui t)
	  #+END_SRC

	  General export settings

	  #+BEGIN_SRC emacs-lisp
        (setq org-html-doctype "xhtml5"
              org-html-html5-fancy t
              org-latex-listings 'minted
              org-latex-pdf-process
              '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
                "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
                "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")
              org-latex-packages-alist '(("" "microtype" nil)
                                         ("" "babel" nil)
                                         ("" "minted" nil)
                                         ("" "lmodern" nil)))
	  #+END_SRC


	  By default, exporting to LaTeX would produce visually unpleasing
	  code. But by enabling [[https://www.ctan.org/texarchive/macros/latex/contrib/minted][minted]], this issue is mitigated quite easily.

	  Furthermore, a few extra default packages are added, which I always
	  enable.

	  #+BEGIN_SRC emacs-lisp
        (dolist (hook '(flyspell-prog-mode
                        turn-on-org-cdlatex))
          (add-hook 'org-mode-hook hook))
	  #+END_SRC

	  Default =flyspell-mode= complains about terms such as ~#+BEGIN_SRC~,
	  but =flyspell-prog-mode= is intelligent enough to ignore these, make
	  sure the former is turned off, while the latter is activated (it's
	  activated in the first place because =org-mode= inherits =text-mode='s
	  hooks).

	  #+BEGIN_SRC emacs-lisp
        (setq org-clock-into-drawer t
              org-log-into-drawer t)
	  #+END_SRC

	  Configure org-mode clocking and logging.

	  #+BEGIN_SRC emacs-lisp
        ;; (require 'ox-html)
        ;; (setf (car (alist-get 'path org-html-mathjax-options))
        ;;       "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")
	  #+END_SRC

	  The default MathJax url that Org-mode uses seems to be depricated,
	  thus I have to update it, using the official CDN.

      #+BEGIN_SRC emacs-lisp
        :config
        (add-to-list 'org-structure-template-alist
                     '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"
                       "<src lang=\"emacs-lisp\">\n\n</src>"))
      #+END_SRC

      Adding this code to =org-structure-template-alist=, makes it easier
      to maintain files like these, since expands =<E= to a source block
      with emacs-lisp automatically chosen as the language. Due to a
      org-mode bug, this has to be evaluated after the document has been
      loaded.

      #+BEGIN_SRC emacs-lisp
        (setq org-latex-preview-ltxpng-directory "/tmp/ltxpng/")
        (plist-put 'org-format-latex-options :scale 1.5)
      #+END_SRC

      LaTeX previews can be a bit small and clutter the working
      directory, so the following options should migrate these issues.

      #+BEGIN_SRC emacs-lisp
        :bind (("C-c c" . org-capture)
               ("C-c a" . org-agenda)
               ("C-c l" . org-store-link)
               :map org-mode-map
               ("M-<tab>" . pcomplete))
      #+END_SRC

      Here I set a few convenient keybindings for globally interacting
      with my org ecosystem.

      Also: [[=flyspell-mode=][Flyspell]] sadly shadows org's auto-complete functionality,
      with an alternative I never use. When instead re-binding =pcomplete=,
      one get's a lot more out of Org, without having to look up
      everyhing in the manual.

      #+BEGIN_SRC emacs-lisp
        :mode ("\\.org\\'" . org-mode))
      #+END_SRC

      Finally, defer interpretation until a =.org= file is found, and
      close the =use-package= block.

	  # #+BEGIN_SRC emacs-lisp
      #   (use-package org-pdfview
      #     :config
      #     (add-to-list 'org-file-apps
      #                  '("\\.pdf\\'" . (lambda (file link)
      #                                    (org-pdfview-open link))))
      #     :after (org pdf-tools))
	  # #+END_SRC

	  # In connotation with [[*PDF%20Viewer][pdf-tools]], I make =org= support specific links
	  # to open pdf files on the correct pages.

**** Markdown
     #+BEGIN_SRC emacs-lisp
       (use-package markdown-mode
         :init
         (setq markdown-italic-underscore t
               markdown-command "cmark")
         :mode "README\\'")
     #+END_SRC

	 Markdown is probably one of the most popular markup languages around
	 nowadays, and tools like [[https://pandoc.org/][Pandoc]] really bring out it's inner
	 potential (or rather create it in the first place). =Markdown-mode=
	 offers nice support for quite a few Pandoc features, so it's usually
	 my default choice when I have to work with medium to longer sized
	 documents.

	 For simple previews, I've set [[https://kristaps.bsd.lv/lowdown][lowdown]] as my markdown processor, due
	 to it's speed (as compared to =markdown.pl= or Pandoc).

*** Programming Languages
**** C
     #+BEGIN_SRC emacs-lisp
       (setq-default c-electric-flag t
                     c-auto-newline nil
                     c-delete-function 'backward-delete-char
                     c-default-style "k&r"
                     c-delete-function #'delete-char
                     c-tab-always-indent t)
	 #+END_SRC

	 From what one can see, it is obvious that I still have to get around
	 to properly set up my C editing environment.

	 #+BEGIN_SRC emacs-lisp
       (setq gdb-display-io-nopopup t
             gdb-show-main t
             gdb-many-windows t)
	 #+END_SRC

	 Currently my only option is to disable a "dedicated" I/O buffer,
	 when running a debugger.

**** Gnuplot
	 #+BEGIN_SRC emacs-lisp
       (use-package gnuplot
         :interpreter ("gnuplot" . gnuplot-mode)
         :mode ("\\.gp\\'" . gnuplot-mode))
	 #+END_SRC

	 =gnuplot= [sic] has been my go-to plotter for a few years now. Most of
	 the time I use it in it's REPL, but especially when working with
	 scripts, =gnuplot-mode= proves itself to be helpful.

	 Due to the wierd package name, and the fact that I use =.gp= as the
	 file extention for gnuplot files, as few things have to be
	 re-aliased for the mode to work properly.

**** Go
	 #+BEGIN_SRC emacs-lisp
       (use-package go-mode
         :init
         (setq gofmt-command "goimports")
         (add-hook 'go-mode-hook
                   (lambda ()
                     (add-hook 'before-save-hook
                               'gofmt-before-save t t)
                     (setq-local compile-command
                                 "go generate && go build -v && go test -v && go vet")))
         :config
         (let* ((go-path  "/home/phi/code/go")
                (go-bin (concat go-path "/bin")))
           (setenv "GOPATH" go-path)
           (setenv "PATH" (concat (getenv "PATH") ":" go-bin))
           (add-to-list 'exec-path go-bin))
         :mode "\\.go\\'"
         :bind (:map go-mode-map
                     ("M-." . godef-jump)
                     ("C-c ." . godoc-at-point)
                     ("C-c C-r" . go-remove-unused-imports)))

       (use-package company-go
         :after (go-mode company)
         :config
         (add-hook 'go-mode-hook
                   (lambda () (setq-local company-backends '(company-go)))))

       (use-package go-eldoc :after go-mode
         :config
         (add-hook 'go-mode-hook 'go-eldoc-setup))
	 #+END_SRC

	 Go can be very fragile, but after having have set up the right files
	 and installed the right extensions, my setup gives a fairly smooth
	 editing experience.

	 Currently, the following packages are installed
	 - [[https://github.com/mdempsky/gocode][gocode]]
	 - [[https://github.com/rogpeppe/godef][godef]]
	 - [[https://golang.org/x/tools/cmd/goimports][goimports]]

**** Rust
	 #+BEGIN_SRC emacs-lisp
       (use-package rust-mode
         :init (setq rust-format-on-save t)
         :mode "\\.rs\\'")
	 #+END_SRC

	 When playing around with Rust, having a Emacs mode installed is
	 convenient.

	 #+BEGIN_SRC emacs-lisp
       (use-package cargo
         :after rust-mode
         :init
         (add-hook 'rust-mode-hook #'cargo-minor-mode))

       (use-package racer
         :after rust-mode
         :init
         (add-hook 'rust-mode-hook #'racer-mode)
         (add-hook 'racer-mode-hook #'eldoc-mode))
	 #+END_SRC

	 Additionally, /cargo/ and /racer/ are lazily loaded, as soon as rust is
	 required.

**** Scheme
	 #+BEGIN_SRC emacs-lisp
       (use-package geiser
         :init
         (setq geiser-repl-use-other-window nil
               geiser-active-implementations '(mit guile))
         (add-hook 'scheme-mode-hook 'geiser-mode)
         :mode ("\\.scm\\'" . scheme-mode))
	 #+END_SRC

	 When properly set up, geiser gives an MIT Scheme-like editing
	 experience. It's not perfect, and it sometimes drags the whole
	 editor down, but for the amount of Scheme programming I do it's
	 entirely sufficient.

**** Java
     #+BEGIN_SRC emacs-lisp
       (with-eval-after-load 'java-mode
         (add-hook 'java-mode-hook
                   (lambda ()
                     (let ((buf (buffer-name))
                           (cls (string-remove-suffix ".java" (buffer-name))))
                       (when (string-suffix-p ".java" buf)
                         (setq-local compile-command (concat "javac " buf "&& java " cls)))))))
     #+END_SRC

     Since I usually only work on single file Java projects, this code

     #+BEGIN_SRC emacs-lisp
       (use-package javadoc-lookup
         :ensure cc-mode
         :config
         (setq javadoc-lookup-completing-read-function completing-read-function)
         :bind (:map java-mode-map
                     ("C-c C-j" . javadoc-lookup)
                     ("C-c C-i" . javadoc-add-import))
         :mode ("\\.java\\'" . java-mode))
     #+END_SRC

	 When "programming" in Java, =javadoc-lookup= helps me easily manage
	 imports as well as open documentation in my preferred browser.

**** Common Lisp
	 #+BEGIN_SRC emacs-lisp
       (use-package slime
         :ensure
         :config
         (setq inferior-lisp-program (executable-find "sbcl")
               slime-contribs '(slime-fancy slime-autodoc))
         (add-hook 'common-lisp-mode-hook 'slime-mode)
         ; (add-hook 'slime-mode-hook 'slime-autodoc-mode)
         :interpreter ("sbcl" . common-lisp-mode)
         :mode (("\\.lisp\\'" . common-lisp-mode)
                ("\\.cl\\'" . common-lisp-mode)))

       (use-package slime-company
         :config
         (add-to-list 'slime-contribs 'slime-company)
         (add-hook 'slime-mode-hook
                   (lambda ()
                     (setq-local company-backends
                                 '(company-slime))))
         :after slime)
	 #+END_SRC

	 Since Elisp and Common Lisp share a common ancestry in Maclisp and
	 Franzlisp (more so that Scheme), it should be worthwhile to learn
	 CL. Additionally, the =cl= library for Emacs seems to be quite popular
	 -- and what better place to learn Common Lisp than in Emacs itself
	 with the popular SLIME (The Superior Lisp Interaction Mode for
	 Emacs) environment?

**** Web Development
	 #+BEGIN_SRC emacs-lisp
       (use-package web-mode
         :init
         (setq web-mode-engines-alist '(("go" . "\\.gtl\\'"))
               web-mode-enable-engine-detection t
               web-mode-markup-indent-offset 4
               web-mode-enable-auto-quoting t
               web-mode-enable-auto-closing t
               web-mode-enable-auto-expanding t
               web-mode-enable-auto-indentation nil
               web-mode-enable-auto-pairing nil)
         :mode (("\\.html\\'" . web-mode)
                ("\\.css\\'" . web-mode)
                ("\\.gtl\\'" . web-mode)))
	 #+END_SRC

	 I conciser =web-mode= an improvement upon =html-mode= in nearly all
	 aspects, which for the first time gave me a comfortable environment
	 to edit HTML and related code. I require no additional
	 configuration, besides informing Emacs about my preferences.

**** Haskell
	 #+BEGIN_SRC emacs-lisp
       (use-package haskell-mode
         :init
         (setq haskell-process-show-debug-tips nil
               haskell-process-type 'ghci
               haskell-process-suggest-hoogle-imports t
               haskell-process-suggest-remove-import-lines t
               haskell-process-auto-import-loaded-modules t
               haskell-process-log t)
         (add-hook 'haskell-mode-hook
                   (lambda ()
                     (haskell-doc-mode)
                     (interactive-haskell-mode)))
         (add-hook 'haskell-interactive-mode-hook
                   'haskell-doc-mode)
         :mode "\\.hs\\'"
         :interpreter "ghci"
         :bind (:map haskell-mode-map
                     ("C-," . haskell-move-nested-left)
                     ("C-." . haskell-move-nested-right)
                     ("C-c C-." . haskell-mode-format-imports)
                     ("C-c C-l" . haskell-process-load-or-reload)
                     ("C-c C-t" . haskell-process-do-type)
                     ("C-c C-i" . haskell-process-do-info)
                     ("C-c C-c" . haskell-process-cabal-build)))
	 #+END_SRC

	 Programming Haskell can be a very nice experience in Emacs, but as
	 always, it has to be properly set up. The keybindings have been
	 copied from [[https://www.reddit.com/r/haskell/comments/3jww0s/can_you_post_your_emacs_configuration_for/cut9j5i][here]].

	 #+BEGIN_SRC emacs-lisp
       (use-package company-ghc
         :config
         (add-hook 'haskell-mode-hook
                   (lambda ()
                     (setq-local company-backends '(company-ghc))))
         :after (haskell-mode company))
	 #+END_SRC

	 For improved interaction, intelligent and informative auto
	 completion is always appreciated.

*** Enchantments
**** Unto Tree
	 #+BEGIN_SRC emacs-lisp
       (use-package undo-tree
         :diminish undo-tree-mode
         :init
         (global-undo-tree-mode)
         :config
         (setq undo-tree-visualizer-timestamps t
               undo-tree-visualizer-diff t))
	 #+END_SRC

	 =Undo-tree= offers the ability to visualize ones editing history as a
	 tree of changes, and to jump from one "branch" to another. Enable
	 it globally, so I "diminish" the minor mode, since it clutters up
	 the mode line more than it has to.

**** Viper
	 #+BEGIN_SRC emacs-lisp
       (setq viper-inhibit-startup-message t
             viper-expert-level 5)
	 #+END_SRC
	 
	 If I were to want to use Vi keybindings, Viper has me covered (evil
	 is too much). These variables are set to prevent Viper from having
	 to set up everything every time I try to use it.

**** Colorful Delimiters
	 #+BEGIN_SRC emacs-lisp
       (use-package rainbow-delimiters
         :config
         (add-hook 'prog-mode-hook 'rainbow-delimiters-mode-enable))
	 #+END_SRC

	 Especially when programming Lisp, color-matching parentheses and
	 brackets can help readability. This feature is offered by
	 =rainbow-delemiters=, that I enable in all programming modes.

**** Multiple Cursors
	 #+BEGIN_SRC emacs-lisp
       (use-package multiple-cursors
         :bind (("C-<" . mc/mark-previous-like-this)
                ("C->" . mc/mark-next-like-this)
                ("C-S-n" . mc/mark-next-lines)
                ("C-S-p" . mc/mark-previous-lines)
                ("C-M-;" . mc/mark-all-like-this-dwim)))
	 #+END_SRC

	 It doesn't take long to adjust to =multiple-cursors-mode=, and it is a
	 feature one turns out to use surprisingly often. While it's not as
	 native or quick, as in other editors (I'm thinking of [[https://github.com/martanne/vis][vis]]), it's for
	 the most part entirely sufficient for my causes.

**** Structural Editing
	 #+BEGIN_SRC emacs-lisp
       (use-package paredit
         :diminish paredit-mode
         :after (lisp-mode emacs-lisp-mode scheme-mode)
         :init
         (add-hook 'scheme-mode-hook 'enable-paredit-mode)
         (add-hook 'lisp-mode-hook 'enable-paredit-mode)
         (add-hook 'emacs-lisp-mode-hook 'enable-paredit-mode)
         (add-hook 'lisp-interaction-mode-hook 'enable-paredit-mode)
         :bind (:map paredit-mode-map
                     ("M-\"" . nil)))
	 #+END_SRC

	 Paredit isn't easy to get used to, but after a while (and a few
	 failed attempts) it becomes natural and one expects it.

**** Goto Source
	 #+BEGIN_SRC emacs-lisp
       (use-package dumb-jump
         :config
         (setq dumb-jump-aggressive t)
         :init
         (add-hook 'prog-mode-hook 'dumb-jump-mode))
	 #+END_SRC

	 In addition to projectile, and to avoid using =TAGS= files, =dumb-jump=
	 offers clean and simple say to navigate a project, and find places
	 where variables were declare and used.

**** Error Checking
	 #+BEGIN_SRC emacs-lisp
       (use-package flycheck
         :config
         (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
         :bind (("C-c <right>" . next-error)
                ("C-c <left>" . previous-error)))
	 #+END_SRC

	 Besides installing flycheck, also disable the Elisp warning
	 regarding checkdoc warnings (/first line must be so and so/, /last line
	 must contain this and that/, ...).

**** Auto Completion
	 #+BEGIN_SRC emacs-lisp
       (use-package company
         :config
         (setq company-begin-commands '()
               company-transformers '(company-sort-by-occurrence)
               company-tooltip-align-annotations t
               company-tooltip-minimum-width 30
               company-tooltip-limit 20
               company-selection-wrap-around t)
         :init
         (add-hook 'prog-mode-hook 'company-mode)
         :bind (:map company-mode-map
                     ("M-<tab>" . company-complete)
                     :map company-active-map
                     ("C-n" . company-select-next)
                     ("C-p" . company-select-previous)))
	 #+END_SRC

	 Generally speaking, I have had a better experiance with =company= as
	 compared to =auto-complete-mode=. The

**** Snippets
	 #+BEGIN_SRC emacs-lisp
       (use-package yasnippet
         :init
         (add-hook 'prog-mode-hook 'yas-minor-mode)
         (setq yas-prompt-functions '(yas-dropdown-prompt yas-completing-prompt)
               yas-wrap-around-region t)
         :config
         (defun indent-then-expand ()
           (interactive)
           (if (and (eq last-command 'indent-then-expand)
                    (not (nth 3 (syntax-ppss)))
                    (not (nth 4 (syntax-ppss))))
               (yas-expand)
             (indent-for-tab-command)))
         (define-key yas-minor-mode-map (kbd "<tab>") #'indent-then-expand))
	 #+END_SRC

	 While I have previously had problems with yasnippets, mainly due to
	 snippets expanding when I don't want them to, recent experience has
	 made me long for a snippet system again. The current system, could
	 work: on =<tab>= snippets are only expanded if the last command was
	 =self-insert-command=, i.e. user input. Otherwise, code will be
	 aligned.

	 #+BEGIN_SRC emacs-lisp
       (use-package yasnippet-snippets :after yasnippet)
	 #+END_SRC

	 Furthermore, make sure a few extra major modes as supported.

*** General Management
**** Ediff
	 #+BEGIN_SRC emacs-lisp
       (setq ediff-window-setup-function 'ediff-setup-windows-multiframe)
	 #+END_SRC

	 When using Ediff, don't create a new window.

**** Version Control
	 #+BEGIN_SRC emacs-lisp
       (use-package magit
         :init
         (setq magit-diff-options "-b --patience")
         :bind (("C-x g" . magit-status)
                ("C-x x g" . magit-status)))
	 #+END_SRC

	 Magit has been noted to be "a git wrapper that's better than git
	 itself" (most definitely not /sic/), and from my experience, this is
	 true, for the most part. Generally speaking, I do think it has a
	 great user experience, and it uses Emacs potential far better than
	 certain other modes. Another way to compliment it, would be to point
	 out how minimal it's configuration needs to be (at least for me),
	 without being in any sense annoying or otherwise inconvenient.

**** Projectile
	 #+BEGIN_SRC emacs-lisp
       (use-package projectile
         :diminish projectile-mode
         :init
         (setq projectile-enable-caching t
               projectile-require-project-root nil
               projectile-switch-project-action 'projectile-dired
               projectile-completion-system 'default)
         :config
         (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
         (projectile-mode t)
         :after ivy)
	 #+END_SRC

	 While I for the most part dislike using global modes, it seems like
	 the project management package /projectile/ works best this way, hence
	 it is set up to work globally.

* Functions
  All private functions and variables shall be prefixed with =zge/=.

** Toggle dictionary
   #+BEGIN_SRC emacs-lisp
     (defconst zge/dicts '("de" "en")
       "list of dictionaries")

     (defconst zge/input-alist '(("en" . nil)
                                 ("de" . "german-postfix")))

     (defconst zge/toggle-dictionary-modes '(text-mode rcirc-mode web-mode))

     (defun zge/toggle-dictionary (&optional lang)
       "Toggle the Ispell dictionary from English to German and vice versa."
       (interactive)
       (unless (boundp 'zge/dict-ring)
         (setq-local zge/dict-ring
                     (let ((ring (make-ring (length zge/dicts))))
                       (mapc (lambda (l) (ring-insert ring l))
                             zge/dicts)
                       ring)))
       (let* ((next-dict (or lang (ring-remove zge/dict-ring)))
              (next-im (assoc next-dict zge/input-alist)))
         (princ next-im)
         (ispell-change-dictionary next-dict)
         (ring-insert zge/dict-ring next-dict)
         (when (and next-im (member nil (mapcar #'not (mapcar #'derived-mode-p zge/toggle-dictionary-modes))))
           (set-input-method (cdr next-im))))
       (save-excursion
         (flyspell-large-region (point-min) (point-max))))
   #+END_SRC

   Since I regularly have to switch between English and German, and I am
   a horrible speller, having a quick function to toggle between just
   the two (using [[%3Dflyspell-mode%3D][flyspell-mode]]) had been very nice. Additionally, my
   input method is changed based on =zge/input-alist=.

   #+BEGIN_SRC emacs-lisp
     (defun zge/org-check-lang ()
       ;; (save-excursion
       ;;   (goto-char (point-min))
       ;;   (do ((line (thing-at-point 'line t)
       ;;              (setq line (thing-at-point 'line t))))
       ;;       ((not (string-empty-p (string-trim line))))
       ;;     (message line)
       ;;     (when (string-match-p "^#+LANGUAGE: de" line)
       ;;       (zge/toggle-dictionary "de"))))
       )

     (add-hook 'org-mode-hook 'zge/org-check-lang)
   #+END_SRC

** Toggle theme
   #+BEGIN_SRC emacs-lisp
     (defconst zge/light-theme 'leuven
       "constant holding my perfered light theme")

     (defconst zge/dark-theme 'wheatgrass
       "constant holding my perfered light theme")

     (defvar zge/current-theme zge/dark-theme
       "variable holding my current theme")

     (defun zge/toggle-theme nil
       "Toggle the current theme from light to dark and vice versa"
       (interactive)
       (let* ((next-theme (if (eq zge/current-theme zge/light-theme)
                              zge/dark-theme zge/light-theme)))
         (disable-theme zge/current-theme)
         (setf zge/current-theme next-theme)
         (load-theme next-theme t)))
   #+END_SRC

   Analogously to =toggle-dictionary=, this function is a quick way to
   switch between the two variations of the theme I use (see
   [[Appearance]]).

   #+BEGIN_SRC emacs-lisp
     (load-theme zge/current-theme)
   #+END_SRC

   Finally, load the current theme, while Emacs is still starting.

** Swap keybindings
   #+BEGIN_SRC emacs-lisp
     (defun swap-keys (kb1 kb2 &optional map)
       "Swap the functions behind KB1 and KB2 in MAP"
       (interactive "kFirst key: \nkSecond key: ")
       (let* ((m (or map (current-global-map)))
              (f1 (lookup-key m kb1))
              (f2 (lookup-key m kb2)))
         (define-key m kb1 f2)
         (define-key m kb2 f1)))
   #+END_SRC

   First mentioned [[https://lobste.rs/s/a0uem2/why_neovim_is_better_than_vim_2015#c_gfs3m7][here]], to argue for elisp v.s. vim script, I don't
   need this function that often, nevertheless I keep in here, just in
   case.

** Roulette
   #+BEGIN_SRC emacs-lisp
     (defun roulette ()
       (interactive)
       (goto-line (random (count-lines (point-min) (point-max))))

       (hl-line-mode t)
       (loop for i from 1 to 50 do
             (if (eobp)
                 (goto-char (point-min))
               (next-line))
             (end-of-line)
             (hl-line-highlight)
             (sit-for (* (+ 0.5 (/ (random 1000) 1250.0)) (sqrt (exp (- i 46.5))))))
       
       (loop repeat 4 do
             (sit-for 0.5)
             (hl-line-highlight)
             (sit-for 0.5)
             (hl-line-unhighlight))
       (hl-line-mode -1))
   #+END_SRC

   This is more of a game, especially a game with the (in)famous =loop=
   macro. The basic concept is to "select" a random line by highlighting
   it with =hl-line-mode= and then continuing on for 50 lines getting
   slower all the time (with a little added randomness). When it ends,
   the "selected" line blinks four times before =hl-line-mode= is turned
   off again.
   
   #+BEGIN_SRC emacs-lisp
     (defun roulette-lines ()
       (interactive)
       (goto-line )

       (hl-line-mode t)
       (goto-line 3)
       (loop for i from 1 to (+ 50 (random (count-lines (point-min) (point-max)))) do
             (save-excursion
               (goto-char (point-min))
               (kill-line 1)
               (goto-char (point-max))
               (yank))
             (goto-line 3)
             (hl-line-highlight)
             (sit-for (* (+ 0.5 (/ (random 1000) 1250.0)) (sqrt (exp (- i 46.5))))))
       
       (loop repeat 4 do
             (sit-for 0.5)
             (hl-line-highlight)
             (sit-for 0.5)
             (hl-line-unhighlight))
       (hl-line-mode -1))
   #+END_SRC

   As a variation on the same concept, but for writable buffers,
   =roulett-lines= actually moves the lines around, keeping the point
   fixed on the 3rd line from the top of the buffer (assuming a "normal"
   buffer).

** Curl to buffer
   #+BEGIN_SRC emacs-lisp
     (defun zge/curl (url)
       "Paste the content behind URL into a new buffer."
       (interactive "Murl: ")
       (let* ((bufname (file-name-base url))
              (buf (get-buffer-create (if (string-empty-p bufname) "*curl*" bufname))))
         (shell-command (concat "curl --silent " url) buf)
         (with-current-buffer buf (set-auto-mode))
         (switch-to-buffer buf)))

     (defalias 'curl 'zge/curl)
   #+END_SRC

   Sometimes I just want to easily view some code in emacs (eg. a raw
   github gist), and this functions just makes it easier.

** Insert C headers
   #+BEGIN_SRC emacs-lisp
     (defvar *c-headers*
       (mapcar (lambda (header) (string-remove-prefix "/usr/include/" header))
               (directory-files-recursively "/usr/include/" "\\.h$")))

     (defun c-insert-header (header)
       (interactive (list (completing-read "Header: " *c-headers*)))
       (save-mark-and-excursion
         (goto-char (point-min))
         (forward-paragraph)
         (insert (concat "#include <" header ">\n"))))

     (with-eval-after-load 'cc-mode
       (define-key c-mode-map (kbd "C-c C-a") #'c-insert-header))
   #+END_SRC

   This function is a simple and primitive mechanism to quickly add c
   headers to a file, using =completing-read= to select a file from
   =/usr/include/=.

** Timestamp
   #+BEGIN_SRC emacs-lisp
     (defun zge/add-timestamp (arg)
       "Prepend a UNIX timestamp to buffer, if it doesn't alreay exits.

     Force prepending timestamp when ARG is non-nil."
       (interactive "P")
       (save-excursion
         (goto-char (point-min))

         (if arg (kill-line 2)
           (uncomment-region (line-beginning-position)
                             (line-end-position)))

         (unless (and (string-match-p "^[[:digit:]]+$"
                                      (string-trim (thing-at-point 'line t)))
                      (not arg))
           (insert (format-time-string "%s"))
           (newline 2)
           (previous-line 2))

         (comment-line 1)))
   #+END_SRC

   For my ad-hoc blog, I insert a UNIX timestamp

* Global Keybindings
  #+BEGIN_SRC emacs-lisp
    (dolist (bind '(("M-\"" . eshell)
                    ("<f5>" . zge/toggle-dictionary)
                    ("<f6>" . zge/toggle-theme)
                    ("<f7>" . toggle-truncate-lines)
                    ("C-c C-k" . compile)
                    ("C-c M-k" . recompile)
                    ("C-c <C-return>" . man)
                    ("C-x x d" . calendar)
                    ("C-x M-k" . kill-buffer-and-window)
                    ("C-x j" . jump-to-register)
                    ("M-#". find-file-at-point)
                    ("<print>" . other-window)
                    ("s-<up>" . windmove-up)
                    ("s-<down>" . windmove-down)
                    ("s-<left>" . windmove-left)
                    ("s-<right>" . windmove-right)
                    ("C-M-<backspace>" . delete-region)))
      (global-set-key (kbd (car bind)) (cdr bind)))
  #+END_SRC

  These are juts a few self-explanatory global, /personal/ keybindings, I
  find useful. All of this is done using the =dolist= macro, to keep
  everything cleaner and easier to read.

  #+BEGIN_SRC emacs-lisp
    (dolist (bind '(("C-x C-b" . ibuffer)
                    ("M-l" . downcase-dwim)
                    ("<backtab>" . completion-at-point)
                    ("M-c" . capitalize-dwim)
                    ("<prior>" . scroll-up-command)
                    ("<next>" . scroll-down-command)
                    ("M-u" . upcase-dwim)
                    ("M-SPC" . cycle-spacing)
                    ("<insert>" . ignore)
                    ("M-/" . hippie-expand)))
      (global-set-key (kbd (car bind)) (cdr bind)))
  #+END_SRC

  These on the other hand, overrride existing, /default/ keybindings with
  different (eg. =C-z= to repeat), or better (eg. =M-SPC= to cycle-spacing)
  commands.

* Hooks
  Most of the mode specific hooks were already set up in the [[Packages%20and%20Other%20Configurations][Packages
  and Other Configurations]] section, so this part only adds a few more
  general hooks, which apply to more than just one mode.

** Programming
   #+BEGIN_SRC emacs-lisp
     (add-hook 'prog-mode-hook
               (lambda ()
                 (add-hook 'before-save-hook
                           'delete-trailing-whitespace t t)
                 (local-set-key (kbd "C-;") 'comment-dwim)
                 (local-set-key (kbd "RET") 'newline-and-indent)
                 (local-set-key (kbd "C-:") 'indent-region)
                 (local-set-key (kbd "C-c w") 'whitespace-mode)
                 (hs-minor-mode t)
                 (electric-indent-local-mode t)
                 (electric-pair-local-mode t)
                 (flycheck-mode t)
                 (flyspell-prog-mode)))
   #+END_SRC

   This lambda function is turned on for every programming mode, and
   specially enables a few keybindings I find useful only when
   programming.

** Writing
   #+BEGIN_SRC emacs-lisp
     (add-hook 'text-mode-hook (lambda ()
                                 (unless (eq major-mode 'org-mode)
                                   (turn-on-flyspell))))
   #+END_SRC

   The only minor-mode I really use when writing text is flyspell. If I
   do need something else, I turn it on manually.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'text-mode-hook 'electric-pair-local-mode)
   #+END_SRC

   All text buffers should automatically close opening parentheses.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'text-mode-hook 'turn-on-auto-fill)
     (advice-add 'auto-fill-function :before
                 (lambda (&rest args) (scroll-right 4096)))
   #+END_SRC

   When writing text, I usually would keep on pressing =M-q= all the time
   to fill paragraphs, until I found out about =auto-fill-mode= that does
   this automatically as soon as lines become too long. My only issue
   then was that if a window was too narrow (but wider that the fill
   width) Emacs would scroll without scrolling back. To remedy this
   issue, I automatically scroll-right, whenever a paragraph is
   auto-fill'ed (currently a bit buggy).
